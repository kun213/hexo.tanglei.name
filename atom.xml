<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐磊的个人博客</title>
  
  <subtitle>记录我的学习、生活、工作。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.tanglei.name/"/>
  <updated>2020-10-23T15:12:13.961Z</updated>
  <id>https://www.tanglei.name/</id>
  
  <author>
    <name>tanglei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020北京积分落户结果公示，落户指标最多的公司竟然又是 ？</title>
    <link href="https://www.tanglei.name/blog/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score.html"/>
    <id>https://www.tanglei.name/blog/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score.html</id>
    <published>2020-10-18T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。欢迎关注，交流和指导！</p><p>本文首发于微信公众号，<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247489970&amp;idx=1&amp;sn=0765365069973269c479eccea07e23bb&amp;chksm=eb471856dc3091407b1b4c4a5dd86ac3d270405ac7e128de9fdc8588278e1fbef8a6d95e499e&amp;token=536564666&amp;lang=zh_CN#rd" target="_blank" rel="noopener">原文链接</a>，转载请全文保留。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>就在昨天，一年一度的北京积分落户结果出来了，我们照旧来看看今年（2020年）的数据情况。</p><p>在看这篇文章之前，你可以通过如下文章来得到石头是如何快速拿到这些数据分析结果的：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247487786&amp;idx=1&amp;sn=842202cc524477ec1546b4747bdbf1a8&amp;chksm=eb4710cedc3099d86953451729c7f569866e6e58abbbec5c7ebe7423d12e1f11e189bb417f80&amp;token=450646044&amp;lang=zh_CN#rd" target="_blank" rel="noopener">优秀的程序员是如何利用工具来提升工作效率的？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483767&amp;idx=1&amp;sn=3b271ed5fbb20ee875f41f1d704398f4&amp;chksm=eb470093dc3089856c39d1181f93c851cf725a8522f2fc65bf72246e2fff97c8e8d7f62fa6b5&amp;token=450646044&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Shell 助力开发效率提升</a> </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247489026&amp;idx=1&amp;sn=cf1650652a44d65730c5ee04258ad9e1&amp;chksm=eb4717e6dc309ef037674943645abe8356aa726416ea46f3349ba227520bd40c95f8a49aa3e5&amp;token=2077533801&amp;lang=zh_CN#rd" target="_blank" rel="noopener">提升开发效率N倍的20+命令行神器!(附 demo)</a></li></ul><p>数据可以通过北京市人力资源和社会保障局官方网站下载获取，<a href="http://rsj.beijing.gov.cn/ywsite/jflh/gg/202010/t20201015_2111656.html" target="_blank" rel="noopener">关于2020年积分落户公示及落户办理有关工作的通告</a>。<a href="http://fuwu.rsj.beijing.gov.cn/nwesqintegralpublic/settleperson/settlePersonTable" target="_blank" rel="noopener">公示名单</a> 形如：</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/2020 年积分落户公式名单.png" alt="2020 年积分落户公式名单"></p><p>点击每一项明细可以获得积分具体数值，以最高分为例：</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/2020积分落户最高分明细.png" alt="2020积分落户最高分明细"></p><p>然后，稍微动点小技巧即可获取完整的 6032 条记录。若你想获取石头初步处理后的 excel 数据，可直接后台回复 “2020积分落户” 取得。</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>输入就是下载处理后的 csv，每行分别为“姓名、出生年月、单位名称、积分分值”。 </p><p>本文将从 积分分数分布、公司分布、年龄分布 等几个方面做简单分析。 </p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/2020年积分落户数据CSV.png" alt="2020年积分落户数据CSV"></p><h3 id="分数分布"><a href="#分数分布" class="headerlink" title="分数分布"></a>分数分布</h3><p>我们来看看积分分布情况，大部分人积分分布在 97~102 分之间。这个分数虽然没有高考相差那么夸张，但一个 0.01 也能相差不少人，比如有 98 人都得了 97.5 分。98.17 有 39 人，少 0.01 的 98.16 有 21 人。 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $5&#125;'</span> 10000.csv |sort | uniq -c | sort -nr -k 1  | head -n 10</span><br><span class="line">  98 97.50</span><br><span class="line">  84 97.25</span><br><span class="line">  80 97.33</span><br><span class="line">  73 97.17</span><br><span class="line">  72 97.21</span><br><span class="line">  67 98.50</span><br><span class="line">  66 98.00</span><br><span class="line">  61 97.46</span><br><span class="line">  57 98.46</span><br><span class="line">  54 97.13</span><br><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $5&#125;'</span> 10000.csv |sort | uniq -c | sort -nr -k 1  | grep 98.17</span><br><span class="line">  39 98.17</span><br><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $5&#125;'</span> 10000.csv |sort | uniq -c | sort -nr -k 1  | grep 98.16</span><br><span class="line">  21 98.16</span><br><span class="line">➜  积分落户2020数据分析 git:(master) ✗</span><br></pre></td></tr></table></figure><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/2020年北京积分落户积分分布.png" alt="2020年北京积分落户积分分布"></p><p>按照上次<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488114&amp;idx=1&amp;sn=b6191483135ecd7f7c0b735bc2dbe7a7&amp;chksm=eb471396dc309a80ba8df35f9e04ab585a80cb3f9e485fdf4c9afd380200c2d109b28335a00b&amp;token=2077533801&amp;lang=zh_CN#rd" target="_blank" rel="noopener">首批积分落户数据分析</a> 的老规矩，拿到这个文件，比如希望你用最快的方法获得以下信息，你将会怎么做？</p><ul><li>获取取得户口名额最多的top10公司</li><li>获取取得户口名额的人中姓氏最多的</li><li>获取年龄分布</li></ul><p>当然，方法有很多，比如熟悉各种编程语言的，例如 <code>python, php, java</code> 等等写个简单的脚本程序，也能比较快获取答案。或者把相应的数据提取出来，放到 excel 中也可以。</p><p>如果你对 Shell 很熟悉，那真的是分分钟，应该是秒秒钟就能获取答案。本文不对 Shell 具体每个命令做过多的解释，不熟悉的同学可以直接 <code>man $cmd</code> 或者 <code>$cmd --help</code> 等等查看。</p><p>之前我也写过一篇名叫 <a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483767&amp;idx=1&amp;sn=3b271ed5fbb20ee875f41f1d704398f4&amp;chksm=eb470093dc3089856c39d1181f93c851cf725a8522f2fc65bf72246e2fff97c8e8d7f62fa6b5&amp;token=450646044&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Shell 助力开发效率提升</a> 的文章，算是给常用的命令的常用参数做了一个解释和示例，有兴趣的同学可以前往查阅。 显然这次的输入数据比上次 <a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488114&amp;idx=1&amp;sn=b6191483135ecd7f7c0b735bc2dbe7a7&amp;chksm=eb471396dc309a80ba8df35f9e04ab585a80cb3f9e485fdf4c9afd380200c2d109b28335a00b&amp;token=2077533801&amp;lang=zh_CN#rd" target="_blank" rel="noopener">首批的 json 数据</a> 更简单。</p><h3 id="获取取得户口名额最多的top10公司"><a href="#获取取得户口名额最多的top10公司" class="headerlink" title="获取取得户口名额最多的top10公司"></a>获取取得户口名额最多的top10公司</h3><p>直接<code>awk</code> 得到公司名字，对结果进行<code>sort</code>排序进行去重<code>uniq</code>统计得到重复次数，次时结果为<code>重复次数 公司名</code>，再对第一列<code>-k 1</code>重复数字进行按照数字排序逆序<code>-nr</code> 即 <code>sort -nr -k 1</code>，最后取结果的前10行 <code>head -n 10</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  首批积分落户  &gt; grep <span class="string">'unit'</span> jifenluohu.json| cut -f2 -d: | sort | uniq -c | sort -nr -k 1 | head -n 10</span><br><span class="line"> 137  <span class="string">"北京华为数字技术有限公司"</span></span><br><span class="line">  73  <span class="string">"中央电视台"</span></span><br><span class="line">  57  <span class="string">"北京首钢建设集团有限公司"</span></span><br><span class="line">  55  <span class="string">"百度在线网络技术（北京）有限公司"</span></span><br><span class="line">  48  <span class="string">"联想（北京）有限公司"</span></span><br><span class="line">  40  <span class="string">"北京外企人力资源服务有限公司"</span></span><br><span class="line">  40  <span class="string">"中国民生银行股份有限公司"</span></span><br><span class="line">  39  <span class="string">"国际商业机器（中国）投资有限公司"</span></span><br><span class="line">  29  <span class="string">"中国国际技术智力合作有限公司"</span></span><br><span class="line">  27  <span class="string">"华为技术有限公司北京研究所"</span></span><br><span class="line">  </span><br><span class="line">  ➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $4&#125;'</span> 10000.csv |sort | uniq -c | sort -nr -k 1 | head -n 10</span><br><span class="line"> 112 北京华为数字技术有限公司</span><br><span class="line">  71 中央电视台</span><br><span class="line">  28 北京外企人力资源服务有限公司</span><br><span class="line">  28 华为技术有限公司北京研究所</span><br><span class="line">  27 中国石油天然气股份有限公司管道北京输油气分公司</span><br><span class="line">  27 北京首钢建设集团有限公司</span><br><span class="line">  24 中国建筑第二工程局有限公司</span><br><span class="line">  24 腾讯科技（北京）有限公司</span><br><span class="line">  24 联想（北京）有限公司</span><br><span class="line">  23 中国新华航空集团有限公司</span><br></pre></td></tr></table></figure><p>对比上次的结果看， “华为” 又是榜首，中央电视台又位列第二，百度下去了，腾讯起来了。（“北京外企人力资源服务有限公司”）挂靠在 FESCO 下的外企，仍然挤进前 10 了。</p><p>以下是有户口指标前 50 的公司分布，快看看你的公司是否在榜（完整公司排名名单请后台回复“2020积分落户”获取）。</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/640-20201018150727450.png" alt="2020年北京积分落户公司分布"></p><h3 id="获取取得户口名额的人中姓氏最多的"><a href="#获取取得户口名额的人中姓氏最多的" class="headerlink" title="获取取得户口名额的人中姓氏最多的"></a>获取取得户口名额的人中姓氏最多的</h3><p>看看想通过积分落户，最好是姓啥，哈哈。</p><p>看结果还是姓 “张, 王” 之类的最有戏。 😁<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  首批积分落户  &gt; grep <span class="string">'"name":'</span> jifenluohu.json| sed <span class="string">'s|"name": "||g'</span> | sed <span class="string">'s| ||g'</span> | cut -c 1 | sort | uniq -c | sort -nr -k 1 | head -n 10</span><br><span class="line"> 541 张</span><br><span class="line"> 531 王</span><br><span class="line"> 462 李</span><br><span class="line"> 376 刘</span><br><span class="line"> 205 陈</span><br><span class="line"> 193 杨</span><br><span class="line"> 166 赵</span><br><span class="line"> 132 孙</span><br><span class="line">  95 郭</span><br><span class="line">  95 徐</span><br><span class="line">  </span><br><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $2&#125;'</span> 10000.csv |cut -c 1 | sort | uniq -c | sort -nr -k 1 | head -n 10</span><br><span class="line"> 553 王</span><br><span class="line"> 477 李</span><br><span class="line"> 457 张</span><br><span class="line"> 369 刘</span><br><span class="line"> 173 陈</span><br><span class="line"> 168 杨</span><br><span class="line"> 165 赵</span><br><span class="line"> 126 孙</span><br><span class="line"> 114 周</span><br><span class="line"> 100 吴</span><br></pre></td></tr></table></figure></p><p>对比这个数据，才发现真的是很牛 X，前 10 名的姓氏中，只有两个不一样。估计这是否也符合整个中国的姓氏？哪里能拿到这部分数据？可以验证一下。</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/640-20201018150737725.png" alt="2020北京积分落户姓氏分布"></p><p>为了把石头的姓氏“唐”找出来，取了前 50 个，发现像平时不怎么常见的姓氏还能入围前 50，还是很有意思的呢。比如“于”、“丁”等。</p><h3 id="获取户口名字中叫啥名最流行"><a href="#获取户口名字中叫啥名最流行" class="headerlink" title="获取户口名字中叫啥名最流行"></a>获取户口名字中叫啥名最流行</h3><p>这个数据没啥意思就不给了，看看重名的数据吧。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $2&#125;'</span> 10000.csv  | sort | uniq -c | sort -nr -k 1 | head -n 10</span><br><span class="line">   9 王鹏</span><br><span class="line">   6 王伟</span><br><span class="line">   6 张颖</span><br><span class="line">   5 赵静</span><br><span class="line">   5 石磊</span><br><span class="line">   5 王琳</span><br><span class="line">   5 王燕</span><br><span class="line">   5 王涛</span><br><span class="line">   5 王勇</span><br><span class="line">   5 孙涛</span><br></pre></td></tr></table></figure><p>作为码农，必须得养成对自己得到结果进行自测的习惯，所以如果对自己的结果不够自信，可以正向去计算一下最终的结果。</p><p>例如可以简单<code>grep</code>一下进行验证，叫 “王鹏” 的是不是9个。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  积分落户2020数据分析 git:(master) ✗ grep <span class="string">'王鹏'</span> 10000.csv</span><br><span class="line">202000543王鹏飞1979-02北京航天发射技术研究所104.09</span><br><span class="line">202001150王鹏1980-03中国扶贫基金会101.80</span><br><span class="line">202001449王鹏1972-10北京汇众博思信息科技有限公司101.25</span><br><span class="line">202002088王鹏1977-11银河航天（北京）通信技术有限公司100.42</span><br><span class="line">202002114王鹏1977-05《中国经济周刊》杂志社100.38</span><br><span class="line">202002753王鹏1976-11北京睿驰青果科技有限公司99.66</span><br><span class="line">202003455王鹏1983-04北京首创股份有限公司98.96</span><br><span class="line">202003514王鹏飞1980-07云粒智慧科技有限公司98.92</span><br><span class="line">202003694王鹏1976-05上海创景计算机系统有限公司北京办事处98.75</span><br><span class="line">202003763王鹏1980-01北京兴庆房地产土地评估有限公司98.71</span><br><span class="line">202004190王鹏1980-09北京欧拓技术有限公司98.34</span><br></pre></td></tr></table></figure><h3 id="获取年龄分布"><a href="#获取年龄分布" class="headerlink" title="获取年龄分布"></a>获取年龄分布</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拿到出生年后, 直接通过 awk 计算结果输出</span></span><br><span class="line">➜  首批积分落户  &gt; grep <span class="string">'"idCard":'</span> jifenluohu.json| cut -f2 -d: | cut -c 9-12 |awk <span class="string">'&#123;print 2019-$1&#125;'</span> | sort | uniq -c</span><br><span class="line">   3 34</span><br><span class="line">  13 35</span><br><span class="line">  39 36</span><br><span class="line"> 109 37</span><br><span class="line"> 162 38</span><br><span class="line"> 302 39</span><br><span class="line"> 507 40</span><br><span class="line"> 773 41</span><br><span class="line"> 799 42</span><br><span class="line"> 813 43</span><br><span class="line"> 757 44</span><br><span class="line"> 586 45</span><br><span class="line"> 507 46</span><br><span class="line"> 378 47</span><br><span class="line"> 238 48</span><br><span class="line">   4 49</span><br><span class="line">   9 50</span><br><span class="line">   1 51</span><br><span class="line">   4 52</span><br><span class="line">   3 53</span><br><span class="line">   2 54</span><br><span class="line">   5 55</span><br><span class="line">   1 56</span><br><span class="line">   1 58</span><br><span class="line">   1 59</span><br><span class="line">   1 60</span><br><span class="line">   1 61  </span><br><span class="line">   </span><br><span class="line">➜  积分落户2020数据分析 git:(master) ✗ awk <span class="string">'&#123;print $3&#125;'</span> 10000.csv  | cut -f1 -d<span class="string">"-"</span> |awk <span class="string">'&#123;print 2020-$1&#125;'</span> | sort | uniq -c</span><br><span class="line">   1 32</span><br><span class="line">   3 35</span><br><span class="line">  30 36</span><br><span class="line">  83 37</span><br><span class="line"> 290 38</span><br><span class="line"> 468 39</span><br><span class="line"> 644 40</span><br><span class="line"> 741 41</span><br><span class="line"> 808 42</span><br><span class="line"> 751 43</span><br><span class="line"> 636 44</span><br><span class="line"> 507 45</span><br><span class="line"> 365 46</span><br><span class="line"> 329 47</span><br><span class="line"> 108 48</span><br><span class="line"> 107 49</span><br><span class="line">  85 50</span><br><span class="line">  27 51</span><br><span class="line">   6 52</span><br><span class="line">  10 53</span><br><span class="line">   9 54</span><br><span class="line">   8 55</span><br><span class="line">   6 56</span><br><span class="line">   5 57</span><br><span class="line">   3 58</span><br><span class="line">   2 59</span><br></pre></td></tr></table></figure><p>上次数据最大 61 岁，最小 34 岁，今年最新的数据最小 32 岁，最大 59 岁。这个 32 岁的看来很牛 X。 看看是谁？1988年出生。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  积分落户2020数据分析 git:(master) ✗ grep <span class="string">'1988'</span> 10000.csv</span><br><span class="line">202004964XX磊1988-07中煤北京煤矿机械有限责任公司97.71</span><br></pre></td></tr></table></figure><p>这位 XX 磊同学确实优秀，（太具体了不太好，隐藏部分吧），看详细得分，因为有荣誉表彰 20 加分，查了下荣誉表彰指标里的“省部级及以上劳模”分为四类：全国劳模、享受全国劳模待遇人员、省部级劳模、享受省部级劳模待遇人员。</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/640-20201018150743678.png" alt="2020年积分落户指标年龄最小者"></p><p>年龄分布如下所示，主要还是集中在 38 ~ 47 岁之间。</p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/640-20201018151830149.png" alt="2020积分落户年龄分布"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这次的数据就先分享到这里，如果你有兴趣，可以到网站上采集更多数据（例如各项分数的明细，例如教育背景、合法稳定就业住所等）进行分析。</p><p>另外，如果你想计算一下自己能获得多少分，可以直接到官网网站进行计算，地址为：<a href="http://fuwu.rsj.beijing.gov.cn/integraltool/tool/simulation" target="_blank" rel="noopener">http://fuwu.rsj.beijing.gov.cn/integraltool/tool/simulation</a> </p><p><img src="/resources/use-shell-to-analysis-2020-people-of-getting-residence-of-beijing-by-score/640-20201018150747644.png" alt="积分落户模拟计算工具"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。欢迎关注，交流和指导！&lt;/p&gt;
&lt;p&gt;本文首发于微信公众号，&lt;a href=&quot;https://mp.weixin.qq.com/s?__
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux" scheme="https://www.tanglei.name/tags/Linux/"/>
    
      <category term="工具" scheme="https://www.tanglei.name/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Shell" scheme="https://www.tanglei.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>给 JDK 报了一个 P4 的 Bug，结果居然……</title>
    <link href="https://www.tanglei.name/blog/a-jdk-bug-releate-to-URI.html"/>
    <id>https://www.tanglei.name/blog/a-jdk-bug-releate-to-URI.html</id>
    <published>2020-09-27T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。</p></blockquote><p>分享一下之前踩的一个坑，背景是这样的： </p><p>我们的项目依赖于一个外部服务，该外部服务提供 REST 接口供我方调用，这是很常见的一个场景。本地和测试环境测试都没有问题，一切就绪上了生产后，程序调用接口就总是网络不通。</p><p>需要说明的是本地、测试环境、生产环境通过不同的域名访问该外部服务。生产程序调用不通，神奇的是在生产环境通过 <code>curl</code> 等命令却能够正常调用对方接口。</p><p><img src="/resources/a-jdk-bug-releate-to-URI/whatjpg.png" alt="img"></p><p>这 TM 就神奇了，唯一不同的就是发起 HTTP 请求的客户端了，估计就是 http客户端有问题了？ 通过最后排查发现，居然发现了一枚 “ JDK 的 bug”……</p><p>下面我们就来重现一下这个问题。 </p><h2 id="server-端准备"><a href="#server-端准备" class="headerlink" title="server 端准备"></a>server 端准备</h2><p>这里用 Nginx 模拟了一下 上文提到的 REST 服务, 假设调用正常返回 <code>&quot;Hello, World\n&quot;</code>，Nginx 配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name test_1.tanglei.name;</span><br><span class="line">    location /testurl &#123;</span><br><span class="line">        add_header Content-Type &apos;text/plain; charset=utf-8&apos;;</span><br><span class="line">        return 200 &quot;Hello, World\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的-client-请求"><a href="#不同的-client-请求" class="headerlink" title="不同的 client 请求"></a>不同的 client 请求</h2><p>下面用不同的 Http client （分别用命令行<code>curl</code>，python的 <code>requests</code>包，和 Java 的 URL 等尝试）去请求。</p><ul><li><code>curl</code> 请求，正常。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_77_245_centos vhost]<span class="comment"># curl -i "http://test_1.tanglei.name/testurl"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 31 May 2017 09:53:01 GMT</span><br><span class="line">Content-Length: 13</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">Hello, World</span><br><span class="line">[root@VM_77_245_centos vhost]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li><code>python requests</code>  正常。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://test_1.tanglei.name/testurl"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line"><span class="string">u'Hello, World\n'</span></span><br></pre></td></tr></table></figure><ul><li>Java 的  <code>java.net.URLConnection</code> 同样正常。</li></ul><p>我们来看一下通过 Java 调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(java.net.URL url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    java.net.URLConnection conn = url.openConnection();</span><br><span class="line">    java.io.InputStreamReader in = <span class="keyword">new</span> java.io.InputStreamReader(conn.getInputStream(), <span class="string">"utf-8"</span>);</span><br><span class="line">    java.io.BufferedReader reader = <span class="keyword">new</span> java.io.BufferedReader(in);    </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">    in.close();</span><br><span class="line">    String response = sb.toString();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个方法 <code>String getContent(java.net.URL url)</code> 传入一个构造好的 <code>java.net.URL</code> 然后 get 请求，并以 <code>String</code> 方式返回 response。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String srcUrl = <span class="string">"http://test_1.tanglei.name/testurl"</span>;</span><br><span class="line">java.net.URL url = <span class="keyword">new</span> java.net.URL(srcUrl);</span><br><span class="line">System.out.println(<span class="string">"\nurl result:\n"</span> + getContent(url)); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上面的语句输出正常，结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url result:</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure><p>这就尼玛神奇了吧。看看我们程序中用的 httpclient 的实现，结果发现是有用 <code>java.net.URI</code>，心想，这不至于吧，用 URI 就不行了么。 </p><p><img src="/resources/a-jdk-bug-releate-to-URI/buzhiyu.png" alt="img"></p><p>换 <code>java.net.URI</code> 试试?  （这里不展开讲URL和URI的区别联系了，可以简单的认为URL是URI的一个子集，详细的可参考 <a href="https://www.ibm.com/developerworks/cn/xml/x-urlni.html" target="_blank" rel="noopener">URI、URL 和 URN</a>, <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank" rel="noopener">wiki URI</a>）</p><p>直接通过<code>java.net.URI</code>构造，再调用 <code>URI.toURL</code> 得到 <code>URL</code>，调用同样正常。</p><p>关键的来了，httpclient 源码中用的构造函数是另外一个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URI(String scheme, String host, String path, String fragment)</span><br><span class="line">Constructs a hierarchical URI from the given components.</span><br></pre></td></tr></table></figure><p>我用这个方法构造<code>URI</code>，会构造失败： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> java.net.URI(uri.getScheme(), uri.getHost(), uri.getPath(), <span class="keyword">null</span>) error: protocol = http host = <span class="keyword">null</span></span><br><span class="line"><span class="keyword">new</span> java.net.URI(url.getProtocol(), url.getHost(), url.getPath(), <span class="keyword">null</span>) error: Illegal character in hostname at index <span class="number">11</span>: http:<span class="comment">//test_1.tanglei.name/testurl</span></span><br></pre></td></tr></table></figure><p>所以问题发现了，我们的项目中依赖的第三方 httpclient包底层用到了 <code>java.net.URI</code>，恰好在 <code>java.net.URI</code> 中是不允许以下划线(<code>_</code>)作为 <code>hostname</code> 字段的。</p><p>即 <code>uri.getHost()</code> 和 <code>uri.toURL().getHost()</code> 居然能不相等。</p><h2 id="这是-JDK-的-Bug-吧？"><a href="#这是-JDK-的-Bug-吧？" class="headerlink" title="这是 JDK 的 Bug 吧？"></a>这是 JDK 的 Bug 吧？</h2><p>有理由怀疑，这是 JDK 的 Bug 吗？</p><p><img src="/Users/tanglei/github/hexo.tanglei.name/source/resources/a-jdk-bug-releate-to-URI/bug.png" alt="image-20200919102937998"></p><p>从官网上还真找到了关于包含下划线作为hostname的bug提交issue，戳这里 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8132508" target="_blank" rel="noopener">JDK-8132508 : Bug JDK-8029354 reproduces with underscore in hostname</a>，然后发现该 “bug” reporter 的情况貌似跟我的差不多，只不过引爆bug的点不一样。</p><p>该 “bug” reviewer 最后以 “Not an Issue” 关闭，给出的理由是：</p><blockquote><p>RFC 952 disallows _ underscores in hostnames. So, this is not a bug. </p></blockquote><p>确实，<a href="https://tools.ietf.org/html/rfc952" target="_blank" rel="noopener">rfc952</a> 明确说了域名只能由 字母 <code>(A-Z)</code>、 数字<code>(0-9)</code>、 减号 <code>(-)</code> 和 点 <code>(.)</code> 组成。</p><p>那 OK 吧，既然明确规定了 hostname 不能包含下划线，为啥 <code>java.net.URL</code> 确允许呢？</p><p>造成 <code>java.net.URI</code> 和 <code>java.net.URL</code> 在处理 hostname 时的标准不一致，且本身 <code>java.net.URI</code> 在构造的时候也带了 “有色”眼镜，同一个url字符串 通过静态方法 <code>java.net.URI.create(String)</code> 或者通过带1个参数的构造方法 <code>java.net.URI(String)</code> 都能成功构造出 URI 的实例，但通过带4个参数的构造方法就不能构造了。 </p><p>要知道，在 coding 过程中，<strong>尽早</strong>反馈异常信息更有利于软件开发持续迭代的过程。我们在开发过程中也应该遵循这一点原则。 </p><p>于是我就去 JDK 官网提交了一个 bug，大意是说 <code>java.net.URI</code> 和 <code>java.net.URL</code> 在处理hostname的时候标准不一致，容易使开发人员埋藏一些潜在的bug，同时也还把这个问题反馈到  <a href="https://stackoverflow.com/questions/44226003/conflicts-between-java-net-url-and-java-net-uri-when-dealing-with-hostname-conta" target="_blank" rel="noopener">stackoverflow</a> 了。</p><blockquote><p>I am wondering, if hostname with underscore is not valid, why the result is differrent between java.net.URI and java.net.URL? Is it a bug or a feature? Here is the example.</p><p>java.net.URL url = new java.net.URL(“<a href="http://test_1.tanglei.name&quot;)" target="_blank" rel="noopener">http://test_1.tanglei.name&quot;)</a>;<br>System.out.println(url.getHost()); //test_1.tanglei.name<br>java.net.URI uri = new java.net.URI(“<a href="http://test_1.tanglei.name&quot;)" target="_blank" rel="noopener">http://test_1.tanglei.name&quot;)</a>;<br>System.out.println(uri.getHost()); //null<br>这个 JDK bug issue 详细信息见 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8170265" target="_blank" rel="noopener">JDK-8170265 : underscore is allowed in java.net.URL while not in java.net.URI</a>, (<a href="https://bugs.openjdk.java.net/browse/JDK-8170265" target="_blank" rel="noopener">openjdk JDK-8170265</a> 更详细）。</p></blockquote><p><img src="/resources/a-jdk-bug-releate-to-URI/jdk-bug.png" alt></p><p>经过初步 Review，被认为是一个 P4 的 Bug，说的是 <code>java.net.URL</code> 遵循的是 <code>RFC 2396</code> 规范，确实不允许含有下划线的 hostname，<code>java.net.URI</code> 做到了， 而 <code>java.net.URL</code> 没有做到。</p><blockquote><p>As per RFC 2396:<br>“Hostnames take the form described in Section 3 of [RFC1034] and<br>Section 2.1 of [RFC1123]: a sequence of domain labels separated by<br>“.”, each domain label starting and ending with an alphanumeric<br>character and possibly also containing “-“ characters.  The rightmost<br>domain label of a fully qualified domain name will never start with a<br>digit, thus syntactically distinguishing domain names from IPv4<br>addresses, and may be followed by a single “.” if it is necessary to<br>distinguish between the complete domain name and any local domain.<br>To actually be “Uniform” as a resource locator, a URL hostname should<br>be a fully qualified domain name.  In practice, however, the host<br>component may be a local domain literal.”</p></blockquote><blockquote><p>URI class is following the above, but URL class doesn’t seem to follow the same rules.</p></blockquote><blockquote><p>To reproduce the issue , run the attached test case.<br>Following is the output on various JDK versions:<br>JDK 8 - Fail<br>JDK 8u112 - Fail<br>JDK 8u122-ea - Fail<br>JDK 9-ea + 141 - Fail</p></blockquote><p>重点来了，然后，却被另外一个 Reviewer 直接个毙了。给出的原因是 <code>java.net.URL</code> 构造方法中，API 文档中说了本来也不会做验证即 <code>No validation of the inputs is performed by this constructor.</code> <a href="https://docs.oracle.com/javase/8/docs/api/java/net/URL.html" target="_blank" rel="noopener">在线 api doc 戳这里</a> (可以点连接，进去搜索关键字 “No validation”)</p><blockquote><p>The constructors of URL class (e.g., <a href="http://download.java.net/java/jdk9/docs/api/java/net/URL.html#URL-java.lang.String-java.lang.String-java.lang.String-" target="_blank" rel="noopener">http://download.java.net/java/jdk9/docs/api/java/net/URL.html#URL-java.lang.String-java.lang.String-java.lang.String-</a>) specifically mention about the validation: </p></blockquote><blockquote><p>“No validation of the inputs is performed by this constructor.” </p></blockquote><blockquote><p>So not throwing an exception isn’t an issue here.</p></blockquote><p><img src="/resources/conflicts-between-java-net-url-and-java-net-uri-when-dealing-with-hostname-contains-underscore/nonsense.jpg" alt></p><p>当初没有收到及时反馈，就没有来得及怼回去。</p><p>其实就算 “No validation of the inputs is performed by this constructor.” 是合理的，里面也只有3个构造函数有这样的说明，按照这样的逻辑是不是说另外的构造函数有验证呢….. (示例中的默认的构造函数都没有说呀)</p><p><a href="http://www.docjar.com/html/api/java/net/URL.java.html" target="_blank" rel="noopener">这里有java.net.URL 的源码</a>，看兴趣的同学可以看看。</p><p>恩，以上就是结论了。</p><p>不过，反正我自己感觉目前Java API 关于这里的设计不太合理，欢迎大家讨论。</p><p><a href="https://stackoverflow.com/questions/44226003/conflicts-between-java-net-url-and-java-net-uri-when-dealing-with-hostname-conta?answertab=active#tab-top" target="_blank" rel="noopener">我在SO提问的这个回答</a>比较有意思，哈哈。</p><blockquote><p>The review is somewhat terse, but the reviewer’s point is the URL constructor is behaving in accordance with its specification. Since the specification explicitly states that no validation is performed, this is not a bug in the code. This is indisputable.</p></blockquote><blockquote><p>What he didn’t spell out is that fixing this inconsistency (by changing the URL class specification) would break lots of peoples’ 20+ year old code Java code. That would be a really bad idea. It can’t happen.</p></blockquote><blockquote><p>So … this inconsistency is a “feature”.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分享一下
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Java" scheme="https://www.tanglei.name/tags/Java/"/>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>分析了获得家庭摇号新能源指标的数据后，我发现了一个秘密</title>
    <link href="https://www.tanglei.name/blog/data-analysis-of-first-new-energy-car-tickets.html"/>
    <id>https://www.tanglei.name/blog/data-analysis-of-first-new-energy-car-tickets.html</id>
    <published>2020-09-17T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。</p></blockquote><p>这两天公布了北京首批家庭新能源小客车指标积分排序结果。</p><p>当然，意料之中，很遗憾，本人并未入围，排名 8W 左右。看样子，要想新能源积分排序上去，还得抓紧增加家庭代际数啊。 </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3MB5qmicS3EJI9OBbATewyZ83VuP8oLKa0T3icFibU9icYJVJ76nKhmVIvA/640.jpg" alt="img"></p><p>让我们来看看这些数据都是怎样的？</p><p>网站下载了 pdf，不便于分析，显然作为程序猿还是习惯用程序员的方式来进行分析，首先还是先转为纯文本文件吧，可转换为 csv。</p><ol><li>网上有工具，可上传 pdf，转 csv。</li><li>可以直接 copy 出来，粘贴纯文本即可。笔者采用了这种方式很快。</li></ol><p>有了前面这两篇文章作为基础，下面这些数据可轻易获得：</p><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247489026&amp;idx=1&amp;sn=cf1650652a44d65730c5ee04258ad9e1&amp;chksm=eb4717e6dc309ef037674943645abe8356aa726416ea46f3349ba227520bd40c95f8a49aa3e5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">提升开发效率N倍的20+命令行神器!(附 demo)</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488114&amp;idx=1&amp;sn=b6191483135ecd7f7c0b735bc2dbe7a7&amp;chksm=eb471396dc309a80ba8df35f9e04ab585a80cb3f9e485fdf4c9afd380200c2d109b28335a00b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">没想到 Shell 命令竟然还能这么玩？| Shell 玩转大数据分析</a></li></ol><p>因为 copy 出来纯文本，姓名和身份证连在一起了，需要拆分一下，很简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat car2020.csv | awk &apos;&#123;print substr($3, 1, match($3,/[0-9]/)-1) &quot;\t&quot;  substr($3, match($3,/[0-9]/)) &quot;\t&quot; $4 &quot;\t&quot; $5 &quot;\t&quot; $6 &quot;\t&quot; $7&#125;&apos; &gt; car-2020.csv</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3ibL5T5lRuGK6u8J6M4IXbLWaficXw4c7qWlM3hUZELc2ILHEAicRDtic9g/640" alt="摇号数据集csv"></p><h4 id="分数分析"><a href="#分数分析" class="headerlink" title="分数分析"></a>分数分析</h4><p>首先，文件结果直接按照分数倒序的。</p><ul><li>最高分 228 分，家庭共 7 个人组成。</li><li>最低分 72 分，2 代 4 人的家庭居多，也有 3 代 4 人的。</li></ul><p>看看分数的分布，大多数围绕着 70 -120 分之间，占比 80%。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat car-2020.csv | awk '&#123;print $5&#125;'  | uniq -c  | sort -k 1 -nr</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3LpFNHXjGIosO9TOBW9cibJqf6icmJehOSdzK7CCe4gpMTfSSTic96cZYQ/640" alt="积分分布"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3eibFsp7PwzDgibkgotibibIp4pHnricjSm5LJicBFUbE6uMG7icZkErXfunMw/640" alt></p><h4 id="家庭情况"><a href="#家庭情况" class="headerlink" title="家庭情况"></a>家庭情况</h4><ul><li><p>家庭代数， 近 70% 为 3 代人。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ Downloads cat car-2020.csv | awk '&#123;print $4&#125;'  | sort | uniq -c</span><br><span class="line">6621 2</span><br><span class="line">13379 3</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3IPMnRyHkjxCXgZgD9dIlhxAR0sSLneJXqr6wYibJlia9aHxFebDk6QibA/640" alt></p></li><li><p>家庭人口数，居然还有 9 口人的。看了下，9 口人 3 代，猜测 双方父母 4 + 两口 2 + 3 小孩？还是怎样的，我看家庭主要申请人也是从第一期就开始申请摇号了，这么大一家人，也没个车牌，也是不容易啊。 </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR366icJickZFKaibZoctAmkib1k3MDQIFibLskNV9hqibRcREqiaarezGXWP3Ng/640" alt></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Downloads cat car-2020.csv | awk '&#123;print $3&#125;'  | sort | uniq -c</span><br><span class="line">4245 3</span><br><span class="line">5124 4</span><br><span class="line">6912 5</span><br><span class="line">2284 6</span><br><span class="line">1240 7</span><br><span class="line"> 193 8</span><br><span class="line">   2 9</span><br></pre></td></tr></table></figure></li></ul><h4 id="摇号主申请人"><a href="#摇号主申请人" class="headerlink" title="摇号主申请人"></a>摇号主申请人</h4><p>太多人从第一年就开始了参与摇号了。 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Downloads cat car-2020.csv | awk '&#123;print substr($6, 1, 4)&#125;'  | sort | uniq -c</span><br><span class="line">6874 2011</span><br><span class="line">7401 2012</span><br><span class="line">3729 2013</span><br><span class="line">1384 2014</span><br><span class="line"> 482 2015</span><br><span class="line"> 111 2016</span><br><span class="line">  19 2017</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3cy2Md9RNibsEo1WYRlpM2mv4mK0zxIBRTM9qh9LhQKShTxv4Rn1ADYw/640" alt="img"></p><p>看了下，从第一期摇号的就有 1367 个。 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Downloads cat car-2020.csv | awk '&#123;print substr($6, 1, 7)&#125;'  | sort | uniq -c </span><br><span class="line">1367 2011-01</span><br><span class="line"> 797 2011-02</span><br><span class="line"> 665 2011-03</span><br><span class="line"> 519 2011-04</span><br><span class="line"> 473 2011-05</span><br><span class="line"> 356 2011-06</span><br><span class="line"> 424 2011-07</span><br><span class="line"> 448 2011-08</span><br><span class="line"> 407 2011-09</span><br><span class="line"> 516 2011-10</span><br><span class="line"> 434 2011-11</span><br><span class="line"> 468 2011-12</span><br></pre></td></tr></table></figure><h4 id="中签者老家哪里的？"><a href="#中签者老家哪里的？" class="headerlink" title="中签者老家哪里的？"></a>中签者老家哪里的？</h4><p>这个，需要借助身份证号对应的行政区域了，思路跟之前 <a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488114&amp;idx=1&amp;sn=b6191483135ecd7f7c0b735bc2dbe7a7&amp;chksm=eb471396dc309a80ba8df35f9e04ab585a80cb3f9e485fdf4c9afd380200c2d109b28335a00b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">没想到 Shell 命令竟然还能这么玩？| Shell 玩转大数据分析</a> 这篇文章上一样，直接给结论吧。先看按照省这个级别来划分的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Downloads join -1 2 -2 1 &lt;(cat car-2020.csv | awk '&#123;print substr($2, 1, 2)&#125;' |sort | uniq -c | sort -k1 -nr | head -n 30 | sort -k2) id-area.code2.sort.txt | sort -k2 -nr</span><br><span class="line">11 14792 北京市</span><br><span class="line">13 1101 河北省</span><br><span class="line">37 638 山东省</span><br><span class="line">41 360 河南省</span><br><span class="line">14 330 山西省</span><br><span class="line">23 296 黑龙江省</span><br><span class="line">21 291 辽宁省</span><br><span class="line">42 239 湖北省</span><br><span class="line">15 224 内蒙古自治区</span><br><span class="line">22 217 吉林省</span><br><span class="line">43 175 湖南省</span><br><span class="line">61 174 陕西省</span><br><span class="line">34 169 安徽省</span><br><span class="line">32 162 江苏省</span><br><span class="line">51 161 四川省</span><br><span class="line">36 135 江西省</span><br><span class="line">12 107 天津市</span><br><span class="line">62 82 甘肃省</span><br><span class="line">33 64 浙江省</span><br><span class="line">35 53 福建省</span><br><span class="line">65 46 新疆维吾尔族自治区</span><br><span class="line">64 34 宁夏回族自治区</span><br><span class="line">45 33 广西壮族自治区</span><br><span class="line">50 21 重庆市</span><br><span class="line">63 19 青海省</span><br><span class="line">53 19 云南省</span><br><span class="line">44 19 广东省</span><br><span class="line">52 17 贵州省</span><br><span class="line">31 12 上海市</span><br><span class="line">46 6 海南省</span><br></pre></td></tr></table></figure><ul><li>第一列：身份证开头的两位，基本定位到省；</li><li>第二列：对应的人数</li><li>第三列：对应省</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3C48bfHnDacmPqt5uCq60TkbTdSJcibtwgX3Xv2LFUGBof2ia8vyL1eJA/640" alt></p><p>从中可以看出，还是老北京占比最大，占比74%了。石头想找个免费的热力地图生成工具展示一下的，短时间之类没找到，先放弃了。</p><ul><li>再看看到市区级别的，参考身份证前 6 位。</li></ul><p>先看看前 30 的吧，基本也就是围绕着北京了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Downloads join -1 2 -2 1 &lt;(cat car-2020.csv | awk '&#123;print substr($2, 1, 6)&#125;' |sort | uniq -c | sort -k1 -nr | head -n 30 | sort -k2) address_code_uniq.csv | sort -k2 -nr</span><br><span class="line">110111 1592 房山区</span><br><span class="line">110223 1531 通县</span><br><span class="line">110224 1439 大兴县</span><br><span class="line">110108 1109 海淀区</span><br><span class="line">110105 1108 朝阳区</span><br><span class="line">110222 1075 顺义县</span><br><span class="line">110229 846 延庆县</span><br><span class="line">110106 734 丰台区</span><br><span class="line">110221 725 昌平县</span><br><span class="line">110226 610 平谷县</span><br><span class="line">110228 599 密云县</span><br><span class="line">110102 570 西城区</span><br><span class="line">110227 557 怀柔县</span><br><span class="line">110101 475 东城区</span><br><span class="line">110104 471 宣武区</span><br><span class="line">110109 415 门头沟区</span><br><span class="line">110103 382 崇文区</span><br><span class="line">110107 332 石景山区</span><br><span class="line">110225 189 房山县</span><br><span class="line">131082 43 三河市</span><br><span class="line">230103 34 南岗区</span><br><span class="line">140202 28 城区</span><br><span class="line">110110 25 燕山区</span><br><span class="line">220104 24 朝阳区</span><br><span class="line">150102 23 新城区</span><br><span class="line">130102 23 长安区</span><br><span class="line">610103 22 碑林区</span><br><span class="line">130203 21 路北区</span><br><span class="line">420106 19 武昌区</span><br><span class="line">130681 18 涿州市</span><br></pre></td></tr></table></figure><p>其中，address_code_uniq.csv 来自 <a href="https://raw.githubusercontent.com/jxlwqq/address-code-of-china/master/address_code.csv，有个坑的地方就是政府官方网站下载的行政区域代码数据" target="_blank" rel="noopener">https://raw.githubusercontent.com/jxlwqq/address-code-of-china/master/address_code.csv，有个坑的地方就是政府官方网站下载的行政区域代码数据</a> <a href="http://www.mca.gov.cn//article/sj/xzqh/2020/" target="_blank" rel="noopener">http://www.mca.gov.cn//article/sj/xzqh/2020/</a>是最新的，有的行政区域代码已撤销，不再使用。（幸亏石头校验了一下结果数据，发现相差比较大）</p><p>但之前已经核发的身份证中不能作废吧。举个例子：行政区划代码110223(北京市 通县)已撤销，新发的身份证中不再使用。</p><p>另外，还发现有一例不是用身份证号码作为证件号码的？看样子是护照？<code>CH1HFP********</code>  这个，我也不懂了。 </p><p>先就这么多吧。另外，若感兴趣的朋友需要本文分析的数据集合用作交流学习使用，可回复“积分排序”获取处理的 Excel和 CSV 文件。</p><p>附《摇号解题积分对照表》</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibv6ysV7I9y3B0ZUNWNKuSR3eXbBD5fTYbiaRNowT5XL2icqqRnXDBKjvIbibiao8O1vnoicB88zLbKmiaOg/640" alt="img"></p><p>回到题目本身，这个㊙️秘密就是：如果要想家庭摇号尽早“中签”，那就赶紧生娃吧，哈哈哈😝，别打我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两天公
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Shell" scheme="https://www.tanglei.name/tags/Shell/"/>
    
      <category term="Mac" scheme="https://www.tanglei.name/tags/Mac/"/>
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
      <category term="开发效率" scheme="https://www.tanglei.name/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>提升开发效率N倍的20+命令行神器!(附 demo)</title>
    <link href="https://www.tanglei.name/blog/make-dev-more-efficiency-with-20-shell.html"/>
    <id>https://www.tanglei.name/blog/make-dev-more-efficiency-with-20-shell.html</id>
    <published>2020-09-10T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。</p></blockquote><p>读者福利：<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488892&amp;idx=1&amp;sn=1b026c5a8688b880ca06c51c816265b1&amp;chksm=eb471498dc309d8eaac5bd296a3971901e624e9abfc5a0add8928f5ebc3a83b8402ebfadd95d&amp;scene=21&amp;token=1758347384&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">点这里送几本我们部门出的新书——《弹性计算：无处不在的算力》</a>，免费包邮到家，欢迎大家来抽奖，也帮忙 review 下抽奖的代码。</p><p>本文主要来源于在之前公司的小组内部的一个小分享，整理成一篇文章po出来。<br>题目叫 “Shell 助力开发效率提升”，更切题的应该是叫“命令行”提升开发效率，这里并没有讲到 Shell 编程，而是主要介绍 Linux 或者 Mac 下常用的一些基本工具命令来帮助处理一些日常事务。</p><p>通过本文的介绍，你应该对相关命令有一个初步的了解，知道比如用什么命令可以完成怎样的操作，<br>至于具体的参数，不需要刻意地背诵，等到需要用到的时候，再去 <code>cmd --help</code> 或者 <code>man cmd</code>，用得多了，常用的命令也就自然记住了。 </p><p>本文首先介绍了 Linux/Mac 下一些常用的命令行工具，然后用具体的示例阐述了常用的命令用法，最后通过一两个案例来说明这些工具的强大之处：</p><ul><li>比如给定一个 nginx 日志文件，能够找出 HTTP 404 请求最多的 top 10 是什么? 比如能找到请求耗时最多的 top 10是什么? </li><li>再比如能够简单的得到每小时的”PV”是多少? 再比如拿到一篇文章， 能否简单统计一下这篇文章单次词频最高的10个词语是什么?</li><li>需要批量改某个文件夹下的文件名，批量将文件夹下的图片压缩成固定大小的，等等。</li></ul><h2 id="Mac-环境"><a href="#Mac-环境" class="headerlink" title="Mac 环境"></a>Mac 环境</h2><ul><li>zsh</li><li>on-my-zsh</li><li>plugin <ul><li>git</li><li>autojump</li><li>osx(man-preview/quick-look/pfd(print Finder director)/cdf(cd Finder))</li></ul></li><li>常用快捷键(<code>bindkey</code>)</li><li>演示: 高亮/git/智能补全/跳转(j, d)…</li></ul><p>这里给大家展示一个小 Demo，之前在视频号（程序猿石头，欢迎关注）中分享的一个小视频，演示了如何在目录之间快速跳转。</p><p>关于 Mac 程序猿提高效率的相关技巧，更多的可以参考以下三篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247485871&amp;idx=1&amp;sn=c877775df684d8ab8c90bf2d38eee98a&amp;chksm=eb47084bdc30815d19182c51571b096a20b79bdee0956f68167ebc8ed3117364ac0602f83658&amp;token=551126633&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">工欲善其事，必先利其器 – Mac 软件推荐（序）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247486659&amp;idx=1&amp;sn=b574d3f2a6af4544ceab48aadaa0a726&amp;chksm=eb470d27dc308431e8789a87e32a597c72cc0f2fe02d6fc80424aec11e41e712326b62603f27&amp;token=551126633&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">有了这几个神器，瞬间逼格就上去了</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247487786&amp;idx=1&amp;sn=842202cc524477ec1546b4747bdbf1a8&amp;chksm=eb4710cedc3099d86953451729c7f569866e6e58abbbec5c7ebe7423d12e1f11e189bb417f80&amp;token=242044315&amp;lang=zh_CN#rd" target="_blank" rel="noopener">优秀的程序员是如何利用工具来提升工作效率的？</a></li></ul><h2 id="Shell-基础命令"><a href="#Shell-基础命令" class="headerlink" title="Shell 基础命令"></a>Shell 基础命令</h2><ul><li><p>which/whereis， 常用 <code>whatis</code>， <code>man</code>， <code>--help</code></p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  .oh-my-zsh git:(master)$ whereis ls</span><br><span class="line">/bin/ls</span><br><span class="line">➜  .oh-my-zsh git:(master)$ <span class="built_in">which</span> ls</span><br><span class="line">ls: aliased to ls -G</span><br></pre></td></tr></table></figure></li><li><p>基本文件目录操作</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm， mkdir， mv， cp， <span class="built_in">cd</span>， ls， ln， file， <span class="built_in">stat</span>， wc(-l/w/c)， head， more， tail， cat...</span><br></pre></td></tr></table></figure></li><li><p>利器 管道: <code>|</code></p></li></ul><h2 id="Shell-文本处理"><a href="#Shell-文本处理" class="headerlink" title="Shell 文本处理"></a>Shell 文本处理</h2><p>这里就是通过案例讲了一下12个命令的大致用法和参数，可以通过点击右边的目录（我博客有目录，公众号上木有）直达你想要了解的命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find, grep, xargs, cut, paste, comm</span><br><span class="line">join, sort, uniq, tr, sed, awk</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>常用参数<ul><li>文件名 <code>-name</code>， 文件类型<code>-type</code>， 查找最大深度<code>-maxdepth</code></li><li>时间过滤(create/access/modify) <code>-[cam]time</code></li><li>执行动作 <code>-exec</code></li></ul></li><li><p>示例</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.json"</span></span><br><span class="line">find . -maxdepth 7 -name <span class="string">"*.json"</span> -<span class="built_in">type</span> f</span><br><span class="line">find . -name <span class="string">"*.log.gz"</span> -ctime +7 -size +1M -delete (atime/ctime/mtime)</span><br><span class="line">find . -name <span class="string">"*.scala"</span> -atime -7 -<span class="built_in">exec</span> du -h &#123;&#125; \;</span><br></pre></td></tr></table></figure></li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul><li><p>常用参数</p><ul><li>-v(invert-match)， </li><li>-c(count)， </li><li>-n(line-number)， </li><li>-i(ignore-case)， </li><li>-l， -L， -R(-r， –recursive)， -e</li></ul></li><li><p>示例</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'partner'</span> ./*.scala -l</span><br><span class="line">grep -e <span class="string">'World'</span> -e <span class="string">'first'</span> -i -R ./  (-e: or)</span><br></pre></td></tr></table></figure></li><li><p>相关命令: <code>grep -z / zgrep / zcat xx | grep</code></p></li></ul><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><ul><li><p>常用参数</p><ul><li>-n(每行列数)， </li><li>-I(变量替换)</li><li>-d(分隔符)， Mac 不支持，注意与GNU版本的区别</li></ul></li><li><p>示例    </p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.jpg"</span> | xargs -n1 -I &#123;&#125; du -sh &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><ul><li><p>常用参数</p><ul><li>-b(字节)</li><li>-c(字符)</li><li>-f(第几列)，-d(分隔符)，f 范围: <code>n, n-, -m, n-m</code></li></ul></li><li><p>示例    </p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"helloworldhellp"</span> | cut -c1-10</span><br><span class="line">cut -d， -f2-8 csu.db.export.csv</span><br></pre></td></tr></table></figure></li></ul><h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><ul><li><p>常用参数</p><ul><li>-d 分隔符</li><li>-s 列转行</li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat file1</span><br><span class="line">1 11</span><br><span class="line">2 22</span><br><span class="line">3 33</span><br><span class="line">4 44</span><br><span class="line">➜  Documents$ cat file2</span><br><span class="line">one     1</span><br><span class="line">two     2</span><br><span class="line">three   3</span><br><span class="line">one1    4</span><br><span class="line"></span><br><span class="line">➜  Documents$ paste -d, file1 file2</span><br><span class="line">1 11, one     1</span><br><span class="line">2 22, two     2</span><br><span class="line">3 33, three   3</span><br><span class="line">4 44, one1    4</span><br><span class="line">➜  Documents$ paste -s -d: file1 file2</span><br><span class="line">a 11:b bb:3 33:4 44</span><br><span class="line">one     1:two     2:three   3:one1    4</span><br></pre></td></tr></table></figure></li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>类似sql中的 <code>...inner join ...on ...</code>， <code>-t</code> 分隔符，默认为空格或tab</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat j1</span><br><span class="line">1 11</span><br><span class="line">2 22</span><br><span class="line">3 33</span><br><span class="line">4 44</span><br><span class="line">5 55</span><br><span class="line">➜  Documents$ cat j2</span><br><span class="line">one     1   0</span><br><span class="line">one     2   1</span><br><span class="line">two     4   2</span><br><span class="line">three   5   3</span><br><span class="line">one1    5   4</span><br><span class="line">➜  Documents$ join -1 1 -2 3 j1 j2</span><br><span class="line">1 11 one 2</span><br><span class="line">2 22 two 4</span><br><span class="line">3 33 three 5</span><br><span class="line">4 44 one1 5</span><br></pre></td></tr></table></figure><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h3><ul><li><p>常用参数</p><ul><li>用法 <code>comm [-123i] file1 file2</code></li><li><strong>字典序列</strong>， 3列: 只在file1/file2/both</li><li><code>-</code> 去掉某列，<code>i</code> 忽略大小写</li></ul></li><li><p>示例</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ seq 1 5 &gt;file11</span><br><span class="line">➜  Documents$ seq 2 6 &gt;file22</span><br><span class="line">➜  Documents$ cat file11</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">➜  Documents$ cat file22</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">➜  Documents$ comm file11 file22</span><br><span class="line">1</span><br><span class="line">        2</span><br><span class="line">        3</span><br><span class="line">        4</span><br><span class="line">        5</span><br><span class="line">    6</span><br><span class="line">➜  Documents$ comm -1 file11 file22</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">6</span><br><span class="line">➜  Documents$ comm -2 file11 file22</span><br><span class="line">1</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">➜  Documents$ comm -23 file11 file22</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li></ul><p>相关命令 <strong>diff</strong>(类似<em>git diff</em>)</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li>常用参数<ul><li>-d， –dictionary-order</li><li>-n， –numeric-sort</li><li>-r， –reverse</li><li>-b， –ignore-leading-blanks</li><li>-k， –key</li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat file2</span><br><span class="line">one     1</span><br><span class="line">two     2</span><br><span class="line">three   3</span><br><span class="line">one1    4</span><br><span class="line">➜  Documents$ sort file2</span><br><span class="line">one     1</span><br><span class="line">one1    4</span><br><span class="line">three   3</span><br><span class="line">two     2</span><br><span class="line">➜  Documents$ sort -b -k2 -r file2</span><br><span class="line">one1    4</span><br><span class="line">three   3</span><br><span class="line">two     2</span><br><span class="line">one     1</span><br></pre></td></tr></table></figure></li></ul><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><ul><li>常用参数<ul><li>-c 重复次数</li><li>-d 重复的</li><li>-u 没重复的</li><li>-f 忽略前几列</li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat file4</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">➜  Documents$ sort file4 | uniq -c</span><br><span class="line">   3 11</span><br><span class="line">   1 22</span><br><span class="line">   1 33</span><br><span class="line">➜  Documents$ sort file4 | uniq -d</span><br><span class="line">11</span><br><span class="line">➜  Documents$ sort file4 | uniq -u</span><br><span class="line">22</span><br><span class="line">33</span><br><span class="line">➜  Documents$ cat file3</span><br><span class="line">one     1</span><br><span class="line">two     1</span><br><span class="line">three   3</span><br><span class="line">one1    4</span><br><span class="line">➜  Documents$ uniq -c -f 1 file3</span><br><span class="line">   2 one     1</span><br><span class="line">   1 three   3</span><br><span class="line">   1 one1    4</span><br></pre></td></tr></table></figure></li></ul><p>注意：<code>uniq</code>比较相邻的是否重复，一般与<code>sort</code>联用</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><ul><li><p>常用参数</p><ul><li>-c 补集</li><li>-d 删除</li><li>-s 压缩相邻重复的</li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ <span class="built_in">echo</span> <span class="string">'1111234444533hello'</span> | tr  <span class="string">'[1-3]'</span> <span class="string">'[a-c]'</span></span><br><span class="line">aaaabc44445cchello</span><br><span class="line">➜  Documents$ <span class="built_in">echo</span> <span class="string">'1111234444533hello'</span> | tr -d <span class="string">'[1-3]'</span></span><br><span class="line">44445hello</span><br><span class="line">➜  Documents$ <span class="built_in">echo</span> <span class="string">'1111234444533hello'</span> | tr -dc <span class="string">'[1-3]'</span></span><br><span class="line">11112333</span><br><span class="line">➜  Documents$ <span class="built_in">echo</span> <span class="string">'1111234444533hello'</span> | tr -s <span class="string">'[0-9]'</span></span><br><span class="line">123453hello</span><br><span class="line">➜  Documents$ <span class="built_in">echo</span> <span class="string">'helloworld'</span> | tr <span class="string">'[:lower:]'</span> <span class="string">'[:upper:]'</span></span><br><span class="line">HELLOWORLD</span><br></pre></td></tr></table></figure></li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul><li>常用参数<ul><li>-d 删除</li><li>-s 替换， g 全局</li><li>-e 多个命令叠加</li><li>-i 修改原文件(Mac下加参数 “”，备份)</li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat file2</span><br><span class="line">one     1</span><br><span class="line">two     2</span><br><span class="line">three   3</span><br><span class="line">one1    4</span><br><span class="line">➜  Documents$ sed <span class="string">"2,3d"</span> file2</span><br><span class="line">one     1</span><br><span class="line">one1    4</span><br><span class="line">➜  Documents$ sed <span class="string">'/one/d'</span> file2</span><br><span class="line">two     2</span><br><span class="line">three   3</span><br><span class="line">➜  Documents$ sed <span class="string">'s/one/111/g'</span> file2</span><br><span class="line">111     1</span><br><span class="line">two     2</span><br><span class="line">three   3</span><br><span class="line">1111    4</span><br><span class="line"><span class="comment">#将one替换成111 并将含有two的行删除</span></span><br><span class="line">➜  Documents$ sed -e <span class="string">'s/one/111/g'</span> -e <span class="string">'/two/d'</span> file2</span><br><span class="line">111     1</span><br><span class="line">three   3</span><br><span class="line">1111    4</span><br><span class="line"><span class="comment"># ()标记(转义), \1 引用</span></span><br><span class="line">➜  Documents$ sed <span class="string">'s/\([0-9]\)/\1.html/g'</span> file2</span><br><span class="line">one     1.html</span><br><span class="line">two     2.html</span><br><span class="line">three   3.html</span><br><span class="line">one1.html    4.html</span><br><span class="line"><span class="comment"># 与上面一样 &amp; 标记匹配的字符</span></span><br><span class="line">➜  Documents$ sed <span class="string">'s/[0-9]/&amp;.html/g'</span> file2</span><br><span class="line">one     1.html</span><br><span class="line">two     2.html</span><br><span class="line">three   3.html</span><br><span class="line">one1.html    4.html</span><br><span class="line">➜  Documents$ cat mobile.csv</span><br><span class="line"><span class="string">"13090246026"</span></span><br><span class="line"><span class="string">"18020278026"</span></span><br><span class="line"><span class="string">"18520261021"</span></span><br><span class="line"><span class="string">"13110221022"</span></span><br><span class="line">➜  Documents$ sed <span class="string">'s/\([0-9]\&#123;3\&#125;\)[0-9]\&#123;4\&#125;/\1xxxx/g'</span> mobile.csv</span><br><span class="line"><span class="string">"130xxxx6026"</span></span><br><span class="line"><span class="string">"180xxxx8026"</span></span><br><span class="line"><span class="string">"185xxxx1021"</span></span><br><span class="line"><span class="string">"131xxxx1022"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ul><li><p>基本参数和语法</p><ul><li>NR 行号， NF 列数量</li><li><code>$1</code> 第1列， <code>$2, $3</code>…</li><li>-F fs  fs分隔符，字符串或正则</li><li>语法:  <code>awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;</code>， 流程如下:<ol><li>执行begin</li><li>对输入每一行执行 <code>pattern{ commands }</code>， pattern 可以是 正则<code>/reg exp/</code>， 关系运算等</li><li>处理完毕， 执行 end</li></ol></li></ul></li><li><p>示例</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat file5</span><br><span class="line">11  11 aa cc</span><br><span class="line">22  22 bb</span><br><span class="line">33  33 d</span><br><span class="line">11  11</span><br><span class="line">11  11</span><br><span class="line"><span class="comment">#行号， 列数量， 第3列</span></span><br><span class="line">➜  Documents$ awk <span class="string">'&#123;print NR"("NF"):"， $3&#125;'</span> file5</span><br><span class="line">1(4): aa</span><br><span class="line">2(3): bb</span><br><span class="line">3(3): d</span><br><span class="line">4(2):</span><br><span class="line">5(2):</span><br><span class="line"><span class="comment">#字符串分割， 打印1，2列</span></span><br><span class="line">➜  Documents$ awk -F<span class="string">"xxxx"</span> <span class="string">'&#123;print $1， $2&#125;'</span> mobile.csv</span><br><span class="line"><span class="string">"130 6026"</span></span><br><span class="line"><span class="string">"180 8026"</span></span><br><span class="line"><span class="string">"185 1021"</span></span><br><span class="line"><span class="string">"131 1022"</span></span><br><span class="line"><span class="comment">#添加表达式</span></span><br><span class="line">➜  Documents$ awk <span class="string">'$1&gt;=22 &#123;print NR":"， $3&#125;'</span> file5</span><br><span class="line">2: bb</span><br><span class="line">3: d</span><br><span class="line"><span class="comment">#累加1到36，奇数，偶数</span></span><br><span class="line">➜  Documents$ seq 36 | awk <span class="string">'BEGIN&#123;sum=0; print "question:"&#125; &#123;print $1" +"; sum+=$1&#125; END&#123;print "="; print sum&#125;'</span> | xargs | sed <span class="string">'s/+ =/=/'</span></span><br><span class="line">question: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 = 666</span><br><span class="line">➜  Documents$ seq 36 | awk <span class="string">'BEGIN&#123;sum=0; print "question:"&#125; $1 % 2 ==1 &#123;print $1" +"; sum+=$1&#125; END&#123;print "="; print sum&#125;'</span> | xargs | sed <span class="string">'s/+ =/=/'</span></span><br><span class="line">question: 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19 + 21 + 23 + 25 + 27 + 29 + 31 + 33 + 35 = 324</span><br><span class="line">➜  Documents$ seq 36 | awk <span class="string">'BEGIN&#123;sum=0; print "question:"&#125; $1 % 2 !=1 &#123;print $1" +"; sum+=$1&#125; END&#123;print "="; print sum&#125;'</span> | xargs | sed <span class="string">'s/+ =/=/'</span></span><br><span class="line">question: 2 + 4 + 6 + 8 + 10 + 12 + 14 + 16 + 18 + 20 + 22 + 24 + 26 + 28 + 30 + 32 + 34 + 36 = 342</span><br></pre></td></tr></table></figure></li></ul><p>其他高级语法：<code>for, while</code> 等， 各种函数等，本身<code>awk</code>是一个强大的语言，可以掌握一些基本的用法。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="日志统计分析"><a href="#日志统计分析" class="headerlink" title="日志统计分析"></a>日志统计分析</h3><p>例如拿到一个nginx日志文件，可以做很多事情，比如看哪些请求是耗时最久的进而进行优化，比如看每小时的”PV”数 等等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ head -n5 std.nginx.log</span><br><span class="line">106.38.187.225 - - [20/Feb/2017:03:31:01 +0800] www.tanglei.name <span class="string">"GET /baike/208344.html HTTP/1.0"</span> 301 486 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1.1.4322) 360JK yunjiankong 975382"</span> <span class="string">"106.38.187.225, 106.38.187.225"</span> - 0.000</span><br><span class="line">106.38.187.225 - - [20/Feb/2017:03:31:02 +0800] www.tanglei.name <span class="string">"GET /baike/208344.html HTTP/1.0"</span> 301 486 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1.1.4322) 360JK yunjiankong 975382"</span> <span class="string">"106.38.187.225, 106.38.187.225"</span> - 0.000</span><br><span class="line">10.130.64.143 - - [20/Feb/2017:03:31:02 +0800] stdbaike.bdp.cc <span class="string">"POST /baike/wp-cron.php?doing_wp_cron=1487532662.2058920860290527343750 HTTP/1.1"</span> 200 182 <span class="string">"-"</span> <span class="string">"WordPress/4.5.6; http://www.tanglei.name/baike"</span> <span class="string">"10.130.64.143"</span> 0.205 0.205</span><br><span class="line">10.130.64.143 - - [20/Feb/2017:03:31:02 +0800] www.tanglei.name <span class="string">"GET /external/api/login-status HTTP/1.0"</span> 200 478 <span class="string">"-"</span> <span class="string">"-"</span> <span class="string">"10.130.64.143"</span> 0.003 0.004</span><br><span class="line">10.130.64.143 - - [20/Feb/2017:03:31:02 +0800] www.tanglei.name <span class="string">"GET /content_util/authorcontents?count=5&amp;offset=0&amp;israndom=1&amp;author=9 HTTP/1.0"</span> 200 11972 <span class="string">"-"</span> <span class="string">"-"</span> <span class="string">"10.130.64.143"</span> 0.013 0.013</span><br></pre></td></tr></table></figure><p>上面是nginx的一个案例， 例如希望找到top 10 请求的path:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 10000 std.nginx.log | awk <span class="string">'&#123;print $8 ", " $10&#125;'</span> | grep <span class="string">',404'</span> | sort | uniq -c | sort -nr -k1 | head -n 10</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">head -n 10000 std.nginx.log | awk <span class="string">'$10==404 &#123;print $8&#125;'</span> |sort | uniq -c | sort -nr -k1 | head -n 10</span><br></pre></td></tr></table></figure><p>当然，你可能一次不会直接处理成功，一般会先少拿一部分数据进行处理看逻辑是否正常， 或者你可以缓存一些中间结果. </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat std.nginx.log | awk <span class="string">'&#123;print $8 "," $10&#125;'</span> | grep <span class="string">',404'</span> &gt;404.log</span><br><span class="line">sort 404.log | uniq -c | sort -nr -k1 | head -n 10</span><br></pre></td></tr></table></figure><p>再比如每小时请求数量，请求耗时等等</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ head -n 100000 std.nginx.log | awk -F: <span class="string">'&#123;print $1 $2&#125;'</span> | cut -f3 -d/ | uniq -c</span><br><span class="line">8237 201703</span><br><span class="line">15051 201704</span><br><span class="line">16083 201705</span><br><span class="line">18561 201706</span><br><span class="line">22723 201707</span><br><span class="line">19345 201708</span><br></pre></td></tr></table></figure><p>其他实际案例 ip block</p><h3 id="案例-db数据订正"><a href="#案例-db数据订正" class="headerlink" title="案例: db数据订正"></a>案例: db数据订正</h3><p>背景: 因为某服务bug，导致插入到db的图片路径不对，需要将形如(安全需要已经将敏感数据替换)<br><code>https://www.tanglei.name/upload/photos/129630//internal-public/shangtongdai/2017-02-19-abcdefg-eb85-4c24-883e-hijklmn.jpg</code><br>替换成<br><code>http://www.tanglei.me/internal-public/shangtongdai/2017-02-19-abcdefg-eb85-4c24-883e-hijklmn.jpg</code>，因为mysql等db貌似不支持直接正则的替换，所以不能够很方便的进行写sql进行替换（就算支持，直接改也有风险的，还是先备份再修改留个“后悔药”）。</p><p>当然将数据导出，然后写 python 等脚本处理也是一种解决方案，但如果用上面的命令行处理，只需要几十秒即可完成。</p><p>步骤:</p><ol><li><p>准备数据</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, photo_url_1, photo_url_2, photo_url_3 <span class="keyword">from</span> somedb.sometable <span class="keyword">where</span> </span><br><span class="line">photo_url_1 <span class="keyword">like</span> <span class="string">'https://www.tanglei.name/upload/photos/%//internal-public/%'</span> <span class="keyword">or</span></span><br><span class="line">photo_url_2 <span class="keyword">like</span> <span class="string">'https://www.tanglei.name/upload/photos/%//internal-public/%'</span> <span class="keyword">or</span></span><br><span class="line">photo_url_3 <span class="keyword">like</span> <span class="string">'https://www.tanglei.name/upload/photos/%//internal-public/%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>替换原文件<br> 一般在用sed替换的时候，先测试一下是否正常替换。 </p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试是否OK</span></span><br><span class="line">head -n 5 customers.csv | sed <span class="string">'s|https://www.tanglei.name/upload/photos/[0-9]\&#123;1,\&#125;/|http://www.tanglei.me|g'</span></span><br><span class="line"><span class="comment"># 直接替换原文件， 可以sed -i ".bak" 替换时保留原始备份文件</span></span><br><span class="line">sed -i <span class="string">""</span> <span class="string">'s|https://www.tanglei.name/upload/photos/[0-9]\&#123;1,\&#125;/|http://www.tanglei.me|g'</span> customers.csv</span><br></pre></td></tr></table></figure></li><li><p>拼接sql， 然后执行</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F， <span class="string">'&#123;print "update sometable set photo_url_1 = " $2, ", photo_url_2 = " $3, ", photo_url_3 = " $4, " where id = " $1 ";" &#125;'</span> customers.csv &gt; customer.sql</span><br><span class="line"><span class="comment">#然后执行sql 即可</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>play framework session</p><ul><li><p>老方式: 需要启play环境， 慢</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">sbt <span class="string">"project site"</span> consoleQuick</span><br><span class="line"><span class="keyword">import</span> play.api.libs._</span><br><span class="line"><span class="keyword">val</span> sec = <span class="string">"secret...secret"</span></span><br><span class="line"><span class="keyword">var</span> uid = <span class="string">"10086"</span></span><br><span class="line"><span class="type">Crypto</span>.sign(<span class="string">s"uid=<span class="subst">$uid</span>"</span>， sec.getBytes(<span class="string">"UTF-8"</span>)) + <span class="string">s"-uid=<span class="subst">$uid</span>"</span></span><br></pre></td></tr></table></figure></li><li><p>新方式: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$  ~/stdcookie.sh 97522</span><br><span class="line">918xxxxdf64abcfcxxxxc465xx7554dxxxx21e-uid=97522</span><br><span class="line">➜  Documents$ cat ~/stdcookie.sh</span><br><span class="line"><span class="comment">#!/bin/bash ##  cannot remove this line</span></span><br><span class="line">uid=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">hash</span>=`<span class="built_in">echo</span> -n <span class="string">"uid=<span class="variable">$uid</span>"</span> | openssl dgst -sha1 -hmac <span class="string">"secret...secret"</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$hash</span>-uid=<span class="variable">$uid</span>"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>统计文章单词频率: 下面案例统计了川普就职演讲原文中词频最高的10个词。</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ head -n3 chuanpu.txt</span><br><span class="line">Chief Justice Roberts， President Carter， President Clinton， President Bush， President Obama， fellow Americans and people of the world， thank you.</span><br><span class="line"></span><br><span class="line">We， the citizens of America， are now joined <span class="keyword">in</span> a great national effort to rebuild our country and restore its promise <span class="keyword">for</span> all of our people. Together we will determine the course of America and the world <span class="keyword">for</span> many， many years to come.</span><br><span class="line">➜  Documents$ cat chuanpu.txt | tr -dc <span class="string">'a-zA-Z '</span> | xargs -n 1 | sort | uniq -c | sort -nr -k1 | head -n 20</span><br><span class="line">  65 the</span><br><span class="line">  63 and</span><br><span class="line">  48 of</span><br><span class="line">  46 our</span><br><span class="line">  42 will</span><br><span class="line">  37 to</span><br><span class="line">  21 We</span><br><span class="line">  20 is</span><br><span class="line">  18 we</span><br><span class="line">  17 America</span><br><span class="line">  15 a</span><br><span class="line">  14 all</span><br><span class="line">  13 <span class="keyword">in</span></span><br><span class="line">  13 <span class="keyword">for</span></span><br><span class="line">  13 be</span><br><span class="line">  13 are</span><br><span class="line">  10 your</span><br><span class="line">  10 not</span><br><span class="line">  10 And</span><br><span class="line">  10 American</span><br></pre></td></tr></table></figure></li><li><p>随机数：比如常常新注册一个网站，随机生成一个密码之类的。  </p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Documents$ cat /dev/urandom | LC_CTYPE=C tr -dc <span class="string">'a-zA-Z0-9'</span> | fold -w 32 | head -n 5</span><br><span class="line">cpBnvC0niwTybSSJhUUiZwIz6ykJxBvu</span><br><span class="line">VDP56NlHnugAt2yDySAB9HU2Nd0LlYCW</span><br><span class="line">0WEDzpjPop32T5STvR6K6SfZMyT6KvAI</span><br><span class="line">a9xBwBat7tJVaad279fOPdA9fEuDEqUd</span><br><span class="line">hTLrOiTH5FNP2nU3uflsjPUXJmfleI5c</span><br><span class="line">➜  Documents$ cat /dev/urandom | head -c32 | base64</span><br><span class="line">WoCqUye9mSXI/WhHODHDjzLaSb09xrOtbrJagG7Kfqc=</span><br></pre></td></tr></table></figure></li><li><p>图片处理压缩，可批量改图片大小等等 <code>sips</code></p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  linux-shell-more-effiency$ sips -g all <span class="built_in">which</span>-whereis.png</span><br><span class="line">/Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">  pixelWidth: 280</span><br><span class="line">  pixelHeight: 81</span><br><span class="line">  typeIdentifier: public.png</span><br><span class="line">  format: png</span><br><span class="line">  formatOptions: default</span><br><span class="line">  dpiWidth: 72.000</span><br><span class="line">  dpiHeight: 72.000</span><br><span class="line">  samplesPerPixel: 4</span><br><span class="line">  bitsPerSample: 8</span><br><span class="line">  hasAlpha: yes</span><br><span class="line">  space: RGB</span><br><span class="line">  profile: DELL U2412M</span><br><span class="line">➜  linux-shell-more-effiency$ sips -Z 250 <span class="built_in">which</span>-whereis.png</span><br><span class="line">/Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">  /Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">➜  linux-shell-more-effiency$ sips -g all <span class="built_in">which</span>-whereis.png</span><br><span class="line">/Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">  pixelWidth: 250</span><br><span class="line">  pixelHeight: 72</span><br><span class="line">  typeIdentifier: public.png</span><br><span class="line">  format: png</span><br><span class="line">  formatOptions: default</span><br><span class="line">  dpiWidth: 72.000</span><br><span class="line">  dpiHeight: 72.000</span><br><span class="line">  samplesPerPixel: 4</span><br><span class="line">  bitsPerSample: 8</span><br><span class="line">  hasAlpha: yes</span><br><span class="line">  space: RGB</span><br><span class="line">  profile: DELL U2412M</span><br><span class="line">➜  linux-shell-more-effiency$ sips -z 100 30 <span class="built_in">which</span>-whereis.png</span><br><span class="line">/Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">  /Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">➜  linux-shell-more-effiency$ sips -g pixelWidth -g pixelHeight <span class="built_in">which</span>-whereis.png</span><br><span class="line">/Users/tanglei/Documents/linux-shell-more-effiency/<span class="built_in">which</span>-whereis.png</span><br><span class="line">  pixelWidth: 30</span><br><span class="line">  pixelHeight: 100</span><br></pre></td></tr></table></figure></li><li><p>命令行处理 JSON 的神器：随着 JSON 通用性，常常需要处理 JSON 数据，这里推荐这个命令行 JSON 处理神器<a href="https://stedolan.github.io/jq/" title="jq is a lightweight and flexible command-line JSON processor" target="_blank" rel="noopener">jq is a lightweight and flexible command-line JSON processor</a></p></li><li>其他还有一个综合应用可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488114&amp;idx=1&amp;sn=b6191483135ecd7f7c0b735bc2dbe7a7&amp;chksm=eb471396dc309a80ba8df35f9e04ab585a80cb3f9e485fdf4c9afd380200c2d109b28335a00b&amp;token=242044315&amp;lang=zh_CN#rd" target="_blank" rel="noopener">没想到 Shell 命令竟然还能这么玩？| Shell 玩转大数据分析</a></li></ul><p>推荐以下参考材料：</p><ul><li>[1] JSON processor: <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></li><li>[2] Linux工具快速教程: <a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html</a></li><li>[3] Linux命令大全: <a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></li><li>[4] Advanced Bash-Scripting Guide: <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a></li><li>[5] UNIX环境高级编程: <a href="https://book.douban.com/subject/25900403" target="_blank" rel="noopener">https://book.douban.com/subject/25900403</a></li></ul><p>​送几本我们部门出的新书，免费包邮到家，欢迎大家来抽奖（两种抽奖方式，详情见下文），也帮忙review下抽奖的代码。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247488892&amp;idx=1&amp;sn=1b026c5a8688b880ca06c51c816265b1&amp;chksm=eb471498dc309d8eaac5bd296a3971901e624e9abfc5a0add8928f5ebc3a83b8402ebfadd95d&amp;scene=21&amp;token=1758347384&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">关于 AI 的数百个问题，清华男神刘云浩教授的 3 万字回复给整得明明白白|附抽奖送书</a></p><p>上文是一个超级大牛关于AI的相关问题解答，抽奖活动在文末。直接公众号后台回复“抽奖” 也是其中一种抽奖方式哦。 </p><p>觉得本号分享的文章有价值，记得添加星标哦。周更很累，不要白 piao，需要来点正反馈，安排个 “一键三连”（点赞、在看、分享）如何？😝 这将是我持续输出优质文章的最强动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。以每篇文章都让人有收获为目的，欢迎关注，交流和指导！文章首发于微信公众号，欢迎关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读者福利
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Shell" scheme="https://www.tanglei.name/tags/Shell/"/>
    
      <category term="Mac" scheme="https://www.tanglei.name/tags/Mac/"/>
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>10 年 bloger 告诉你要不要写博客，又该如何优雅地写博客？</title>
    <link href="https://www.tanglei.name/blog/how-to-blog-elegantly-as-a-software-engineer.html"/>
    <id>https://www.tanglei.name/blog/how-to-blog-elegantly-as-a-software-engineer.html</id>
    <published>2020-08-23T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。用不同的视角分享高质量技术文章，以每篇文章都让人有收获为目的，欢迎关注，交流和指导！公众号后台回复关键字 “1024” 获取程序员大厂面试指南。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>石头大约在 2010 年左右有了自己的第一个域名，也是从那个时候开始写博客的。至今确实有 10 年时间了。</p><p>最初玩 blog，其实更多的还是抱着学习的态度。比如刚学习完了 DNS 解析，HTML 语法，不 “实战”一把么？后续陆陆续续把读书笔记、课程总结都往博客上放。</p><p>为什么要写 blog，石头觉得有如下几个好处：</p><ul><li>可以把它作为整理学习笔记的地方，方便沉淀学习，就跟当初我开始玩一样。更多的是写给自己看，玩玩“建站”流程（独立博客），也算一个小技能。（其实要不要写博客看个人兴趣，<strong>但学会总结沉淀是必须的</strong>）</li><li>“成就自己、帮助他人”。 在日常工作中，你肯定也有通过别人的博客解决了你的某个问题，这个时候“反哺”一下开放的互联网也何尝不是一件快事。当有人通过搜索引擎检索到你的内容并留言说感谢帮助他解决一个类似问题的时候，还是有一丝丝成就感的。</li><li>锻炼写作能力。一个问题自己懂和把它讲给别人懂，是两个完全不一样的概念。</li><li>打造个人 IP。例如著名的 coolshell，ruanyifeng 等，大部分人应该都知道吧？</li><li>赚钱。这个就不用多说了。说出来，你可能不信，就连我 10 年前没啥内容的 blog，当初也有是有“外快”赚的：记得当初是给“友链”的方式导流，1 个月 5~10 块，刚好能覆盖域名、虚拟主机的费用，不过后来各种博客搬家，也懒得折腾了。</li><li>… </li></ul><p>通过这 10 年的摸索，石头也尝试过多种写 blog 的方法。不过说来惭愧，貌似也没什么说得出的成绩。</p><p>目前也积累了有 400+篇文章，不过感觉真正有质量的文章也就几十来篇。折腾过很多 blog 程序，陆陆续续迁移了好几个版本，历史文章也”舍不得”丢弃，也一直保留。其实好多文章在我现在看来好像价值不大，但扔舍不得抛弃，毕竟当初辛辛苦苦 po 出来的。感兴趣的同学可以通过 “<a href="http://www.tanglei.name”" target="_blank" rel="noopener">www.tanglei.name”</a> 这个网址进行访问。</p><p><img src="http://www.tanglei.name/resources/how-to-blog-elegantly-as-a-software-engineer/image-20200823151456726.png" alt></p><p>下面以我的博客演进之路为例，给大家介绍下常见的博客玩法，供大家参考。</p><h2 id="我的博客之路"><a href="#我的博客之路" class="headerlink" title="我的博客之路"></a>我的博客之路</h2><h3 id="纯-wordpress"><a href="#纯-wordpress" class="headerlink" title="纯 wordpress"></a>纯 wordpress</h3><p>wordpress 不做多介绍，是一套用 php 开发的 CMS，很多人的博客都用这个。</p><p>下图是我博客最初级的版本，在相当长一段时间内也一直用这个主题。</p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/wordpress.tanglei.name.jpg" alt="Wordpress 博客"></p><p>“时光荏苒、岁月如梭”，上面的截图也很有意思——</p><ul><li><p>右上角的动态“腾讯微博”，不知道你有没有用过？</p></li><li><p>左上角的 Rss 订阅，现在不知道是否还有人用，用的人多吗？反正我好久没打开我的订阅文章了。</p></li></ul><p>用 Wordpress 写博客，有一个缺点就是，每次写需要登录后台，排版、配图等比较麻烦。并且还得掏钱买虚拟主机、自己运营维护 wordpress 程序、MySQL 等。</p><p>再后来接触到 <code>markdown</code> 这个标记言，才发现这玩意太好用了，就一发不可收拾。一直用 markdown 写作沿用至今。</p><h3 id="wordpress-markdown-插件"><a href="#wordpress-markdown-插件" class="headerlink" title="wordpress + markdown 插件"></a>wordpress + markdown 插件</h3><p>博客主题想保留就一直还是用 wordpress，但有希望写作用 markdown。</p><p>由于没有找到合适的 wordpress 的 markdown 插件，于是就自己写了一个 <a href="https://github.com/tl3shi/markdown2wordpress" target="_blank" rel="noopener">markdown2wordpress</a>。后端框架等仍然用 wordpress，繁琐的排版等问题就直接交给 markdown，也不用登陆 wordpress 后台进行调整等操作。</p><p>这个工具依赖于 python-wordpress-xmlrpc，一个 python 实现的 wordpress 的客户端，可以方便调用 wordpress 提供的接口，markdown 的渲染依赖于 pandoc，代码高亮用的是 <code>highlight.js</code><br>图片用图床的形式，或者直接以 github 外链的形式。</p><p>用这个工具又坚持了一段时间。</p><p>但石头当初买的虚拟主机（共享型）还是多个人公用的形式，性能较差，网站就经常挂，一会虚拟机挂了，一会MySQL又挂了，然后还中过木马。实在是忍受不了了。</p><h3 id="github-page-服务"><a href="#github-page-服务" class="headerlink" title="github page 服务"></a>github page 服务</h3><p>github page 服务 <a href="https://pages.github.com/，按照官网说的那样，直接将源文件托管在" target="_blank" rel="noopener">https://pages.github.com/，按照官网说的那样，直接将源文件托管在</a> Github 上，仅仅需要编辑、push即可，然后变化马上就能体现了。 </p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/github-pages.png" alt="image-20200823183039944"></p><p>这样不但省去了虚拟主机、MySQL 等费用，同时 github page 还支持自定义域名、git 版本管理，markdown 自动渲染简直就是专门给程序员量身定做的（好像确实也是的）。</p><p>程序猿只用专注于写 markdown 文件即可，渲染 html 等都交给 gitub。</p><p>下图是我搭建后的一个截图。</p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/github-octopress.jpeg" alt="github和octopress配置"></p><p>详细过程可以参考下我的这几篇 Blog：</p><ul><li><p><a href="https://www.tanglei.name/blog/use-github-to-make-hello-world.html">GitHub搭建博客教程</a></p></li><li><p><a href="https://www.tanglei.name/blog/github-with-octopress.html">也试试github+octopress</a> </p></li></ul><p>再搭建过程中，还会涉及到历史文章的迁移等，感兴趣的可以参考<a href="https://www.tanglei.name/blog/give-up-wordpress-to-jekyll.html">最终还是放弃了Wordpress</a>。</p><p>github pages 服务的好处在于，博主们真正关注的只需要写 markdown 就可以了(类似写论文用 latex 一样)，根本不用去关注比如在 wordpress 后台排版，传图片等等操作。 </p><h3 id="github-pages-travis-ci"><a href="#github-pages-travis-ci" class="headerlink" title="github pages + travis-ci"></a>github pages + travis-ci</h3><p>github pages 服务本身支持的博客引擎比较少，比如希望一些定制化的插件等，github pages 默认服务就不够了。</p><p>但本质上讲，github pages 服务就是提供了一个自定义域名解析到静态 html 的 repo。markdown 转 html 的这个过程， github 支持得不够，可以通过其他的方式。</p><p>比如本地写 markdown，然后本地安装 hexo 等博客引擎，渲染成 html 后直接 push 到 github page 的远程仓库即可。</p><p>我曾经也使用过多个博客引擎，如下图：</p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/jekyll.tanglei.name.jpg" alt="jekyll博客主题"></p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/hexo.tanglei.name.jpg" alt="hexo主题"></p><p>这里推荐一个工具 —— travis，它是一款免费的 CI 工具，能帮你做的事情是啥？ 就是上面你本地的流程可以交给它来做。现在我写 blog 的流程是：</p><ol><li>本地写 blog，md 格式的。工具可以直接用之前推荐的 <a href="https://mp.weixin.qq.com/s/PlDF6pn55vE1_7rusC3K2w" target="_blank" rel="noopener">程序员利器</a> 中的 markdown 写作工具 Macdown 或者 Typora。</li><li>git commit &amp;&amp; git push 即可。</li><li>travis 开始工作，安装 blog 程序，然后 build 静态 html，最后 push 到指定的 github pages 仓库。</li></ol><p>贴一下我的 travis 配置，大家就知道是怎么玩的了。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - master</span><br><span class="line">language: node_js</span><br><span class="line"></span><br><span class="line"># v14/stable(2020-05) produces empty html https://github.com/hexojs/hexo/issues/4257</span><br><span class="line">node_js:</span><br><span class="line">    - 'v13.8.0'</span><br><span class="line"></span><br><span class="line">cache: npm</span><br><span class="line"></span><br><span class="line">before_install:</span><br><span class="line">- git config --global user.name "tangleithu"</span><br><span class="line">- git config --global user.email travis@tanglei.name</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo g</span><br><span class="line">- git log | head -n 6</span><br><span class="line">- export COMMIT=`git log | head -n 1`</span><br><span class="line">- mv public .deploy &amp;&amp; cd .deploy &amp;&amp; du -sh</span><br><span class="line">- git init &amp;&amp; git add -A . &amp;&amp; git commit -m "commit from travis, origin $COMMIT" </span><br><span class="line">- git push --force "https://tl3shi:$GITHUB_TOKEN@github.com/tl3shi/hexo.tanglei.name.git" master:gh-pages</span><br></pre></td></tr></table></figure><p>通过上面的配置可以看出，其实做的事情就是安装博客程序 hexo，然后生成静态 html，最后将本地生成的静态 html 整体打包作为一个仓库 push 到github pages 对应的仓库。</p><p>下图是 travis-ci 的配置页面，可以配置比如只要有新的 commit push 即可触发 CI 流程，进而更新博客内容。</p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/travis-ci-config.png" alt="travis-ci 配置"></p><p>别看整个过程看起来比较复杂，其实安装等过程是可以 cache 的，一般而言，走完整个流程所耗费的时间也就 1-2 分钟（后图所示），因为我的博客内容“历史包袱重”，可能耗费时间会更久，这时间大部分取决于博客程序的处理流程以及最后 git 上传过程。</p><p>下图是构建历史，构建成功与否会邮件方式通知到你，很方便。</p><p><img src="/resources/how-to-blog-elegantly-as-a-software-engineer/travis-history.png" alt="travis 构建历史"></p><p>借助 travis 可玩的东西就多了，上面的 scripts 有足够的灵活性可以自己随意定制。</p><p>比如，是不是可以同一文章多个平台发。举例，现在大家普遍玩法是各大博客平台同步发表。是否可以直接在 CI 流程里面添加 juejin、博客园等 post 流程呢？</p><p>感兴趣的朋友试试？（石头好久都有这个想法了，但却一直没有付出行动）</p><h3 id="解决-github-慢的问题"><a href="#解决-github-慢的问题" class="headerlink" title="解决 github 慢的问题"></a>解决 github 慢的问题</h3><p>用 github 确实很方便，各种免费的服务白piao，但缺点也比较明显，就是国内访问比好慢。gitee 也提供类似的服务，但前面看了一眼，自定义域名好像要收费？</p><p>一个比较简单的方法是用 CDN 来解决这个问题。 blog 本身全是静态资源，html、图片等，很适合用 CDN 来加速。 </p><p>在这篇<a href="https://www.tanglei.name/blog/try-qcloud-vm-cdn.html">云服务器，域名备案及 CDN 服务体验</a> 文章中，我记录了之前具体的流程。</p><p>CDN 的工作流程就是你添加一个域名的 CNAME，指向 CDN 厂商的域名，所以用户发起请求的时候实际是解析到云厂商的 CDN 服务器的，CDN 后台配置一个源站点，例如 <code>www.tanglei.name</code>，用户请求到 CDN 服务器时，如果没有命中，则就去源站点请求并将内容缓存至 CDN 服务器。</p><p>以下是我之前测试 CDN 的一个效果截图。</p><p><img src="http://www.tanglei.name/resources/qcloud/www.tanglei.me-ping-cdn.png" alt="CDN配置效果图"></p><p>下图是访问一个 <a href="http://www.tanglei.name/blog/app-in-mac-for-common.html">含有一些图片的页面</a>的测试结果，其中： </p><ul><li>请求 <code>www.tanglei.name</code> 会直接路由到 github pages 的文件；</li><li>通过 <code>www.tanglei.me</code> 会走云厂商的 CDN；</li></ul><p><img src="http://www.tanglei.name/resources/qcloud/tanglei.name-vs-tanglei.me-cdn.png" alt="CDN测试结果tanglei.name"></p><p>访问一个 10K 的页面，基本在半秒就加载完毕了，对于个人博客来讲，已经很够用了。上图的结果还有一些如 USA 的节点拉低了平均值，国外的一些节点还是走 github 更快。如果有需求做全球加速的话，还可以用比如敝司的全球加速服务哦（CDN包括海外众多节点）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文只是石头在探索过程发现觉得合适自己的方法，每个人喜欢的姿势可能不一样，仅供参考。希望你能找到适合你的姿势。</p><p>觉得本号分享的文章有价值，记得添加星标哦。别白 piao，需要来点正反馈，安排个 “一键三连”（点赞、在看、分享）如何？😝 这将是我持续输出优质文章的最强动力。</p><p><img src="/resources/一键三连.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。用不同的视角分享高质量技术文章，以每篇文章都让人有收获为目的，欢迎关注，交流和指导！公众号后台回复关键字 “1024” 获取程序员大厂面
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>面试官：会玩牌吧？给我讲讲洗牌算法和应用场景吧！</title>
    <link href="https://www.tanglei.name/blog/shuffle-algorithm.html"/>
    <id>https://www.tanglei.name/blog/shuffle-algorithm.html</id>
    <published>2020-07-18T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<p>有一次参加面试，面试官问我：“会玩牌吧？”</p><p><img src="https://static01.imgkr.com/temp/3dd28e16a9ae45858913c98be35c4d76.png" alt></p><p>内心：“咋滴，这是要玩德州扑克（或者炸金花），赢了他就能通过面试么？”</p><p>结果……</p><p>没想到面试官的下一句话：“给我讲讲洗牌算法以及它的应用场景吧！”</p><p><img src="https://static01.imgkr.com/temp/225551c21c1f4437a9deb17aeda15177.png" alt="哈哈，以上内容纯属虚构"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文产生背景是看到了 <code>一枝花算不算浪漫</code> 同学的这篇 <a href="https://mp.weixin.qq.com/s/bSIKnw5446Ocb63Covk2Fw" target="_blank" rel="noopener">Eureka注册中心集群如何实现客户端请求负载及故障转移？</a>文章想到的。其实本人觉得那篇文中提到的负责均衡的重点就是本文要说的洗牌算法。</p><p>好了，回到题目上来。</p><p>这确实也是一道面试题，我曾经多次面试中都有遇到这个题目或者这个题目的变种。</p><p>你不妨花 1 秒，想想？</p><p><img src="https://static01.imgkr.com/temp/dd508c001bef4c9e9cc6a88802983ec0.png" alt></p><h2 id="什么是洗牌算法"><a href="#什么是洗牌算法" class="headerlink" title="什么是洗牌算法"></a>什么是洗牌算法</h2><p>从名字上来看，就是给你一副牌让你洗呗，用怎样的方法才能洗得均匀呢？<br>请大佬表演一下。</p><p><img src="https://static01.imgkr.com/temp/609655ff110e4ca5a6164e777cfdbaa6.gif" alt="不好意思，翻车了"></p><p>其实洗牌算法就是一种随机算法，你在斗地主的时候，随机把牌的顺序打乱就行。一个足够好的洗牌算法最终结果应该是可以让牌的顺序足够随机。好像有点绕~</p><p>这么来说吧，一副牌大家斗地主的话用 54 张（不考虑你们打配配牌的情形哈），那么这 54 张牌的顺序的话，按照排列组合算法，应该是有 <code>54!</code> 这么多种，然后你的洗牌算法就是从这 <code>54!</code> 种排列中，随机选 1 种。</p><p><img src="https://static01.imgkr.com/temp/5dae931b74434a6282a7f98451dd6158.png" alt></p><p>无聊的石头算了一下，54 的阶乘有多大呢？大概就是这么大一长串数字，<code>2308436973392413804720927448683027581083278564571807941132288000000000000L</code>，准确答案看下图：</p><p><img src="https://imgkr.cn-bj.ufileos.com/59a89bd0-0e53-4bba-b60f-7ab063685f1b.png" alt="54的阶乘计算结果"></p><p>我们还是以 4 张牌作为例子吧。</p><p>4 张牌，<code>JQKA</code>，所有的排列有 <code>4!=4*3*2*1=24</code> 种，分别如下： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&apos;J&apos;, &apos;Q&apos;, &apos;K&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;J&apos;, &apos;Q&apos;, &apos;A&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;J&apos;, &apos;K&apos;, &apos;Q&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;J&apos;, &apos;K&apos;, &apos;A&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;J&apos;, &apos;A&apos;, &apos;Q&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;J&apos;, &apos;A&apos;, &apos;K&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;J&apos;, &apos;K&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;J&apos;, &apos;A&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;K&apos;, &apos;J&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;K&apos;, &apos;A&apos;, &apos;J&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;A&apos;, &apos;J&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;Q&apos;, &apos;A&apos;, &apos;K&apos;, &apos;J&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;J&apos;, &apos;Q&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;J&apos;, &apos;A&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;Q&apos;, &apos;J&apos;, &apos;A&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;Q&apos;, &apos;A&apos;, &apos;J&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;A&apos;, &apos;J&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;K&apos;, &apos;A&apos;, &apos;Q&apos;, &apos;J&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;J&apos;, &apos;Q&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;J&apos;, &apos;K&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;Q&apos;, &apos;J&apos;, &apos;K&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;Q&apos;, &apos;K&apos;, &apos;J&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;K&apos;, &apos;J&apos;, &apos;Q&apos;)</span><br><span class="line">(&apos;A&apos;, &apos;K&apos;, &apos;Q&apos;, &apos;J&apos;)</span><br></pre></td></tr></table></figure><p>那么，一个均匀的洗牌算法，就是每次洗牌完后，获得上面每种顺序的概率是相等的，都等于<code>1/24</code>。感觉已经出来了一种算法了，那就是先像前文所述把所有的排列情况都枚举出来，分别标上号 1-24 号，然后从 24 中随机取一个数字（先不考虑如何能做到随机取了，这个话题好像也没那么容易），获取其中这个数字对应的号的排列。</p><p>这个算法复杂度是多少？假设为 <code>N</code> 张牌的话，应该就是 <code>1/N!</code>（注意是阶乘，这里可不是感叹号），显然复杂度太高了。</p><p>有没有更好的方法呢？答案当然是肯定的。</p><h2 id="经典的洗牌算法"><a href="#经典的洗牌算法" class="headerlink" title="经典的洗牌算法"></a>经典的洗牌算法</h2><p>洗牌算法实际上是一个很经典的算法，在经典书籍《算法导论》里面很靠前的部分就有讲解和分析。</p><p>我们把这个洗牌过程用更加“程序员”的语言描述一下，就是假设有一个 <code>n</code> 个元素的数组 <code>Array[n]</code>，通过某种方式，随机产生一个另外一个序列<code>Array&#39;[n]</code>让数组的每个元素 <code>Array[i]</code> 在数组中的每个位置出现的概率都是<code>1/n</code>。</p><p>其实方法可以这样，依此从 <code>Array</code> 中随机选择 1 个，依此放到 <code>Array&#39;</code> 中即可。<br>证明一下：</p><ul><li><code>Array[0]</code>，在新数组的第 0 个位置处的概率为：<code>1/n</code>，因为随机选，只能是<code>1/n</code>的概率能选中；</li><li><code>Array[1]</code>，在新数组的第 1 个位置处的概率为：<code>1/n</code>，因为 第一次没选中 <code>Array[1]</code>的概率为 <code>n-1/n</code>，再结合第二次（只剩下n-1个了，所以分母为<code>n-1</code>）选中的概率为：<code>1/n-1</code>，因此概率为：$\frac{n-1}{n} * \frac{1}{n-1} = \frac{1}{n}$ 。</li><li>依此类推，可以证明前述问题。</li></ul><p>其实，我们也可以不用另外找个数组来存结果，<code>Array&#39;</code>也可以理解为还是前面的这个 <code>Array</code>，只不过里面元素的顺序变化了。</p><p>这其实可以理解为一个 “排序”（其实是乱序） 过程，算法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = list.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = random(i, n); <span class="comment">// 随机产生 [i, n) 中的一个数，每个概率一致</span></span><br><span class="line">    <span class="comment">// list 中第 i 个元素和 第 j 个元素互换位置 </span></span><br><span class="line">    swap(list[i], list[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是如何证明呢？不能你说随机就随机吧，你说等概率就等概率吧。下面还是跟着石头哥一起来看看如何证明吧（这也是面试中的考察点）。</p><p>我们假设经过排序后，某个元素 <code>Array[x]</code> 恰好排在位置 <code>x</code> 处的概率为 $P_x$，<br>则该元素恰好排在第 <code>x</code> 处的概率是前 <code>x-1</code> 次时都没有被随机到，并且第 <code>x</code> 次时，恰好 <code>random(x, n) = x</code>了。 </p><p>还是在循环中列举几项，更好理解一些（写完，才发现跟前面的解释差不多）：</p><ul><li><code>i = 0</code>, <code>random(0, n)</code> 没有返回 x，共 <code>n</code> 个数，肯定返回了其他 <code>n-1</code> 个中的一个，因此概率为 $\frac{n-1}{n}$</li><li><code>i = 1</code>, <code>ramdom(1, n)</code> 没有返回 x，共 <code>n - 1</code> 个数，肯定返回了其他 <code>n-2</code> 个中的一个，即该为 $\frac{n-2}{n-1}$</li><li>依此类推……</li><li><code>i = x-1</code>, <code>random(x-1, n)</code> 没有返回 x，共 <code>n - (x-1)</code> 个数，肯定返回了其他<code>n-(x-1)-1</code> 个中的一个，即为 $\frac{n-(x-1)-1}{n - (x-1)}=\frac{n-x}{n - x+1}$</li><li><code>i = x</code>，<code>random(x, n)</code> 恰好返回了 x，共 <code>n-x</code> 个数，概率为 $\frac{1}{n-x}$</li></ul><p>$p_x = \frac{n-1}{n} <em> \frac{n-2}{n-1} </em>…<em> \frac{n-x}{n - x+1}</em> \frac{1}{n-x} = \frac{1}{n}$</p><p>因此，到这算是简单证明了任何元素出现在任何位置的概率是相等的。</p><p>注意说明一下，这是理论上的值，概率类的问题在量不大的情况下​很有可能有随机性的。就像翻硬币​，正反面理论上的值都是一半一半的，但你不能说一定是正反面按照次序轮着来。​</p><h2 id="看看-JDK-中的实现"><a href="#看看-JDK-中的实现" class="headerlink" title="看看 JDK 中的实现"></a>看看 JDK 中的实现</h2><p>我们还是来看看 JDK 中的实现。JDK 中 <code>Collections</code> 中有如下的实现方法 <code>shuffle</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="comment">// 石头备注：本机特定版本中的常量 SHUFFLE_THRESHOLD=5</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上能看懂大概，不过是不是看看源码还是能获得新技能的。</p><p>上面条件分支大概分两类：</p><ul><li>如果是数组类型，就是可以 <code>O(1)</code>随机访问的List；或者传入的 list 小于 <code>SHUFFLE_THRESHOLD</code>。</li><li>否则的话不能随机访问的链表类型，则花 <code>O(n)</code> 转成数组，再 shuffle，最后又回滚回链表。转成数组的目的很简单，可以快速定位某个下标的元素。</li></ul><p>第一步的这个 <code>SHUFFLE_THRESHOLD</code> 其实就是一个经验调优值，即便假设不能通过快速下标定位某个元素（即需要遍历的方式定位），当输入的 size 比较小的时候，和先花 <code>O(n)</code>转成数组最后又转回成链表 相比，也能有更快的速度。</p><p>另外多说一句，其实这种参数化调优方式在各种语言实现的时候很常见的，比如你去看排序算法的实现中，比如 Java 中 <code>Arrays.sort</code> 就是用的 <code>DualPivotQuicksort</code>（源码在<code>java.util.DualPivotQuicksort</code>中），里面实现逻辑中，当数组大小较小时也是用的其他如 $O(n^2)$ 的插入排序，如下图所示。</p><p><img src="https://imgkr.cn-bj.ufileos.com/40f415b6-7074-4f11-a1cb-bc0407397a97.png" alt></p><h2 id="洗牌算法的应用"><a href="#洗牌算法的应用" class="headerlink" title="洗牌算法的应用"></a>洗牌算法的应用</h2><p><del>肝到 凌晨 2 点了，明天继续写吧….</del></p><p><img src="https://static01.imgkr.com/temp/af18db05cc254e0bb50d0917eae1ba78.png" alt="第二天继续肝"></p><p>回到本篇标题说的应用场景上来，比如开篇提到的 Eureka 注册中心的 Client 就是通过把server 的 IPList 打乱顺序，然后挨个取来实现理论上的均匀的负载均衡。</p><p>代码（在 github: Netflix/eureka 中，公众号就不单独贴出来了）在这里<a href="https://github.com/Netflix/eureka/blob/dad077108c54041a41add075c0e373783a173e2a/eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ResolverUtils.java" target="_blank" rel="noopener"><code>com.netflix.discovery.shared.resolver.ResolverUtils</code></a>。看代码如下，是不是跟前文的算法差不多？（具体写法不一样而已）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends EurekaEndpoint&gt; <span class="function">List&lt;T&gt; <span class="title">randomize</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; randomList = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">    <span class="keyword">if</span> (randomList.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> randomList;</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(LOCAL_IPV4_ADDRESS.hashCode());</span><br><span class="line">    <span class="keyword">int</span> last = randomList.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = random.nextInt(randomList.size() - i);</span><br><span class="line">        <span class="keyword">if</span> (pos != i) &#123;</span><br><span class="line">            Collections.swap(randomList, i, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> randomList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，在任何需要打乱顺序的场景里面都可以用这个算法，举个例子，播放器一般都有随机播放的功能，比如你自己有个歌单 list，但想随机播放里面的歌曲，就也可以用这个方法来实现。</p><p>还有，就比如名字中的“洗牌”，那些棋牌类的游戏，当然会用到名副其实的“洗牌”算法了。其实在各种游戏的随机场景中应该都可以用这个算法的。​</p><h2 id="扩展一下，留道作业题"><a href="#扩展一下，留道作业题" class="headerlink" title="扩展一下，留道作业题"></a>扩展一下，留道作业题</h2><p>跟这个问题类似的，还有一些常见的面试题，本人之前印象中也被问到过（石头特地去翻了翻当年校招等找工作的时候收集和积累的面试题集）。</p><p>以下题目来源于网络，因为是当初准备面试时候收集的，具体来源不详了。​</p><p><img src="https://static01.imgkr.com/temp/1b20066375134f39a913fcfba34690bd.png" alt="动动脑筋，思考一下"></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h3><p>给你一个文本文件，设计一个算法随机从文本文件中抽取一行，要保证每行被抽取到的概率一样。 </p><p>最简单的思路其实就是：先把文件每一行读取出来，假设有 <code>n</code> 行，这个时候随机从 <code>1-n</code>生成一个数，读取对应的行即可。 </p><p>这种方法当然可以解决，咱们加深一下难度，假设文件很大很大很大呢，或者直接要求只能遍历该文件内容一遍，怎么做到呢？</p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h3><p>其实题目 1 还可以扩展一下，不是选择 1 行了，是选择 <code>k</code> 行，又应该怎么做呢？</p><p><img src="https://static01.imgkr.com/temp/243222ae15844d16bdc6ac3d7bd6d037.png" alt></p><p>本人才疏学浅，如果有不对的地方，还望大家指出。</p><p>欢迎大家留言讨论文末的两个小问题的解决思路和方法。</p><p>原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗，或者转发分享让更多的小伙伴看到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一次参加面试，面试官问我：“会玩牌吧？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/3dd28e16a9ae45858913c98be35c4d76.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;内心：“咋滴，这是要玩德州扑克（
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>这 10 行比较字符串相等的代码给我整懵逼了，不信你也来看看</title>
    <link href="https://www.tanglei.name/blog/timing-attack-of-safe-equals.html"/>
    <id>https://www.tanglei.name/blog/timing-attack-of-safe-equals.html</id>
    <published>2020-06-25T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<p>抱歉用这种标题吸引你点进来了，不过你不妨看完，看看能否让你有所收获。​（有收获，请评论区留个言，没收获，下周末我直播吃**，哈哈，这你也信）</p><blockquote><p>补充说明：微信公众号改版，对各个号主影响还挺大的。目前从后台数据来看，对我影响不大，因为我这反正都是小号，😂阅读量本身就少的可怜，真相了，🐶狗头（刚从交流群学会的表情）。</p></blockquote><p>先直接上代码： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">safeEqual</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (a.length() != b.length()) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> equal = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">       equal |= a.charAt(i) ^ b.charAt(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> equal == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是我根据原版（<code>Scala</code>）翻译成 <code>Java</code>的，<code>Scala</code> 版本（最开始吸引程序猿石头注意力的代码）如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safeEqual</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length != b.length) &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> equal = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="type">Array</span>.range(<span class="number">0</span>, a.length)) &#123;</span><br><span class="line">      equal |= a(i) ^ b(i)</span><br><span class="line">    &#125;</span><br><span class="line">    equal == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始看到这段源码感觉挺奇怪的，这个函数的功能是比较两个字符串是否相等，首先“长度不等结果肯定不等，立即返回”这个很好理解。</p><p>再看看后面的，稍微动下脑筋，转弯下也能明白这其中的门道：通过异或操作<code>1^1=0, 1^0=1, 0^0=0</code>，来比较每一位，如果每一位都相等的话，两个字符串肯定相等，最后存储累计异或值的变量<code>equal</code>必定为 0，否则为 1。</p><h2 id="再细想一下呢？"><a href="#再细想一下呢？" class="headerlink" title="再细想一下呢？"></a>再细想一下呢？</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="type">Array</span>.range(<span class="number">0</span>, a.length)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a(i) ^ b(i) != <span class="number">0</span>) <span class="comment">// or a(i) != b[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们常常讲性能优化，从效率角度上讲，难道不是应该只要中途发现某一位的结果不同了（即为1）就可以立即返回两个字符串不相等了吗？(如上所示) </p><p>这其中肯定有……</p><p><img src="https://imgkr.cn-bj.ufileos.com/0d90724a-9e67-42ff-9db5-53453fba1abf.png" alt></p><h2 id="再再细想一下呢？"><a href="#再再细想一下呢？" class="headerlink" title="再再细想一下呢？"></a>再再细想一下呢？</h2><p>结合方法名称 <code>safeEquals</code> 可能知道些眉目，与安全有关。</p><blockquote><p>本文开篇的代码来自playframewok 里用来验证cookie(session)中的数据是否合法(包含签名的验证)，也是石头写这篇文章的由来。</p></blockquote><p>以前知道通过延迟计算等手段来提高效率的手段，但这种已经算出结果却延迟返回的，还是头一回！</p><p>我们来看看，JDK 中也有类似的方法，如下代码摘自 <code>java.security.MessageDigest</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">byte</span>[] digesta, <span class="keyword">byte</span>[] digestb)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (digesta == digestb) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (digesta == <span class="keyword">null</span> || digestb == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (digesta.length != digestb.length) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// time-constant comparison</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digesta.length; i++) &#123;</span><br><span class="line">       result |= digesta[i] ^ digestb[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释知道了，目的是为了用常量时间复杂度进行比较。</p><p>但这个计算过程耗费的时间不是常量有啥风险？ （脑海里响起了背景音乐：“小朋友，你是否有很多问号？”）</p><p><img src="https://imgkr.cn-bj.ufileos.com/327a7a80-6fd7-4b4f-b836-78fc9399ce34.png" alt></p><h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><p>再深入探索和了解了一下，原来这么做是为了防止<strong>计时攻击</strong>（Timing Attack）。（也有人翻译成时序攻击​）​</p><p><img src="https://imgkr.cn-bj.ufileos.com/43ae6be8-c869-4bfa-bab9-77435893afb4.png" alt></p><h2 id="计时攻击-Timing-Attack"><a href="#计时攻击-Timing-Attack" class="headerlink" title="计时攻击(Timing Attack)"></a>计时攻击(Timing Attack)</h2><p>计时攻击是边信道攻击(或称”侧信道攻击”， Side Channel Attack， 简称SCA) 的一种，边信道攻击是一种针对软件或硬件设计缺陷，走“歪门邪道”的一种攻击方式。</p><p>这种攻击方式是通过功耗、时序、电磁泄漏等方式达到破解目的。在很多物理隔绝的环境中，往往也能出奇制胜，这类新型攻击的有效性<strong>远高于</strong>传统的密码分析的数学方法（某百科上说的）。</p><p>这种手段可以让调用 <code>safeEquals(&quot;abcdefghijklmn&quot;, &quot;xbcdefghijklmn&quot;)</code> （只有首位不相同）和调用 <code>safeEquals(&quot;abcdefghijklmn&quot;, &quot;abcdefghijklmn&quot;)</code> （两个完全相同的字符串）的所耗费的时间一样。防止通过大量的改变输入并通过统计运行时间来暴力破解出要比较的字符串。 </p><p>举个🌰，如果用之前说的“高效”的方式来实现的话。假设某个用户设置了密码为 <code>password</code>，通过从a到z（实际范围可能更广）不断枚举第一位，最终统计发现 <code>p0000000</code> 的运行时间比其他从任意<code>a~z</code>的都长（因为要到第二位才能发现不同，其他非 <code>p</code> 开头的字符串第一位不同就直接返回了），这样就能猜测出用户密码的第一位很可能是<code>p</code>了，然后再不断一位一位迭代下去最终破解出用户的密码。</p><p>当然，以上是从理论角度分析，确实容易理解。但实际上好像通过统计运行时间总感觉不太靠谱，这个运行时间对环境太敏感了，比如网络，内存，CPU负载等等都会影响。</p><p>但安全问题感觉更像是 “宁可信其有，不可信其无”。为了防止(特别是与签名/密码验证等相关的操作)被 <strong>timing attack</strong>，目前各大语言都提供了相应的安全比较函数。各种软件系统（例如 OpenSSL）、框架（例如 Play）的实现也都采用了这种方式。 </p><p>例如 “世界上最好的编程语言”（粉丝较少，评论区应该打不起架来）—— php中的: </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compares two strings using the same time whether they're equal or not.</span></span><br><span class="line"><span class="comment">// This function should be used to mitigate timing attacks; </span></span><br><span class="line"><span class="comment">// for instance, when testing crypt() password hashes.</span></span><br><span class="line">bool hash_equals ( string $known_string , string $user_string )</span><br><span class="line"></span><br><span class="line"><span class="comment">//This function is safe against timing attacks.</span></span><br><span class="line">boolean password_verify ( string $password , string $hash )</span><br></pre></td></tr></table></figure><p>其实各种语言版本的实现方式都与上面的版本差不多，将两个字符串每一位取出来异或(<code>^</code>)并用或(<code>|</code>)保存，最后通过判断结果是否为 0 来确定两个字符串是否相等。 </p><p>如果刚开始没有用 <code>safeEquals</code> 去实现，后续的版本还会通过打补丁的方式去修复这样的安全隐患。  </p><p>例如 <a href="http://www.oracle.com/technetwork/java/javase/6u17-141447.html" title="Release Notes" target="_blank" rel="noopener">JDK 1.6.0_17 中的Release Notes</a>中就提到了<code>MessageDigest.isEqual</code> 中的bug的修复，如下图所示：</p><p><img src="https://static01.imgkr.com/temp/7e264b6f9f6141e9a779f07bd29ebd64.png" alt="MessageDigest timing attack vulnerabilities"></p><p>大家可以看看这次变更的的详细信息<a href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/rev/562da0baf70b" title="openjdk中的 bug fix diff" target="_blank" rel="noopener">openjdk中的 bug fix diff</a>为：</p><p><img src="https://static01.imgkr.com/temp/87adf41576964e8bafb2abf48c6a95ab.png" alt="MessageDigest.isEqual计时攻击"></p><h2 id="Timing-Attack-真的可行吗？"><a href="#Timing-Attack-真的可行吗？" class="headerlink" title="Timing Attack 真的可行吗？"></a>Timing Attack 真的可行吗？</h2><p>我觉得各大语言的 API 都用这种实现，肯定还是有道理的，理论上应该可以被利用的。<br>这不，学术界的这篇论文就宣称用这种计时攻击的方法破解了 <code>OpenSSL 0.9.7</code> 的RSA加密算法了。关于 <a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=100000109&amp;idx=1&amp;sn=e65143adf4f81cc5c559b03c58d029e9&amp;chksm=6b4700895c30899f6148025c6120844bd0aeb2d09413ad4ece33f2ea49296fa6f54d17447f63#rd" target="_blank" rel="noopener">RSA 算法的介绍</a>可以看看之前本人写的这篇文章。 </p><p>这篇<a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf" title="Remote Timing Attacks are Practical" target="_blank" rel="noopener">Remote Timing Attacks are Practical</a> 论文中指出（我大致翻译下摘要，感兴趣的同学可以通过文末链接去看原文）：</p><p>计时攻击往往用于攻击一些性能较弱的计算设备，例如一些智能卡。我们通过实验发现，也能用于攻击普通的软件系统。本文通过实验证明，通过这种计时攻击方式能够攻破一个基于 OpenSSL 的 web 服务器的私钥。结果证明计时攻击用于进行网络攻击在实践中可行的，因此各大安全系统需要抵御这种风险。</p><p>最后，本人毕竟不是专研完全方向，以上描述是基于本人的理解，如果有不对的地方，还请大家留言指出来。感谢。</p><blockquote><p>补充说明2：感谢正在阅读文章的你，让我还有动力继续坚持更新原创。</p><p>本人发文不多，但希望写的文章能达到的目的是：占用你的阅读时间，就尽量能够让你有所收获。</p><p>如果你觉得我的文章有所帮助，还请你帮忙转发分享，另外请别忘了点击公众号右上角加个星标，好让你别错过后续的精彩文章（微信改版了，或许我发的文章都不能推送到你那了）。</p></blockquote><p>​原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗，或者转发分享让更多的小伙伴看到。<br>​<br>参考资料：</p><ul><li><a href="http://www.cs.sjsu.edu/faculty/stamp/students/article.html" target="_blank" rel="noopener">Timing Attacks on RSA: Revealing Your Secrets through the Fourth Dimension</a></li><li><a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf" target="_blank" rel="noopener">Remote Timing Attacks are Practical</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抱歉用这种标题吸引你点进来了，不过你不妨看完，看看能否让你有所收获。​（有收获，请评论区留个言，没收获，下周末我直播吃**，哈哈，这你也信）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充说明：微信公众号改版，对各个号主影响还挺大的。目前从后台数据来看，对我影响不大，因为我这
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="网络安全" scheme="https://www.tanglei.name/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一行代码引来的安全漏洞就让我们丢失了整个服务器的控制权</title>
    <link href="https://www.tanglei.name/blog/a-security-vulnerability-of-spring-validator.html"/>
    <id>https://www.tanglei.name/blog/a-security-vulnerability-of-spring-validator.html</id>
    <published>2020-05-24T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某厂的某次项目开发中，项目组同学设计和实现了一个“引以为傲”，额，有点扩张，不过自认为还说得过去的 feature，结果临上线前被啪啪打脸，因为实现过程中因为<strong>一行代码</strong>（没有标题党，真的是一行代码）带来的安全漏洞让我们丢失了整个服务器控制权（测试环境）。多亏了上线之前有公司安全团队的人会对代码进行扫描，才让这个漏洞被扼杀在摇篮里。</p><p>下面我们就一起来看看这个事故，啊，不对，是故事。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-0.png" alt></p><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>我们的项目是一个面向全球用户的 Web 项目，用 SpringBoot 开发。在项目开发过程中，离不开各种异常信息的处理，比如表单提交参数不符合预期，业务逻辑的处理时离不开各种异常信息（例如网络抖动等）的处理。于是利用 SpringBoot 各种现成的组件支持，设计了一个统一的异常信息处理组件，统一管理各种业务流程中可能出现的错误码和错误信息，通过国际化的资源配置文件进行统一输出给用户。</p><h3 id="统一错误信息配置管理"><a href="#统一错误信息配置管理" class="headerlink" title="统一错误信息配置管理"></a>统一错误信息配置管理</h3><p>我们的用户遍布全球，为了给各个国家用户比较好的体验会进行不同的翻译。具体而言，实现的效果如下，为了方便理解，以“找回登录密码”这样一个业务场景来进行阐述说明。</p><p>假设找回密码时，需要用户输入手机或者邮箱验证码，假设这个时候用户输入的验证码通过后台数据库（可能是Redis）对比发现已经过期。在业务代码中，只需要简单的 <code>throw new ErrorCodeException(ErrorCodes.AUTHCODE_EXPIRED)</code> 即可。具体而言，针对不同国家地区不同的语言看到的效果不一样：</p><ul><li>中文用户看到的提示就是“您输入的验证码已过期，请重新获取”；</li><li>欧美用户看到的效果是“The verification code you input is expired, …”；</li><li>德国用户看到的是：“Der von Ihnen eingegebene Verifizierungscode ist abgelaufen, bitte wiederholen” 。（我瞎找的翻译，不一定准）</li><li>……</li></ul><h3 id="统一错误信息配置管理代码实现"><a href="#统一错误信息配置管理代码实现" class="headerlink" title="统一错误信息配置管理代码实现"></a>统一错误信息配置管理代码实现</h3><p>关键信息其实就在于一个 GlobalExceptionHandler，对所有Controller 入口进行 AOP 拦截，根据不同的错误信息，获取相应资源文件配置的 key，并从语言资源文件中读取不同国家的错误翻译信息。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BadRequestException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BadRequestException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ErrorCodeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ErrorCodeException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.OK).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.tanglei.name/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-tree.png" alt="不同语言的资源文件示例"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getI18nMessage</span><span class="params">(String key, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LanguaggeUtils.currentLocale(request));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// log</span></span><br><span class="line">       <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细代码实现可以参考本人之前写的这篇文章<a href="/blog/custom-validator-and-i18n-error-message-in-springboot.html">一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</a>，上面有附完整的代码实现。</p><h3 id="基于注解的表单校验（含自定义注解）"><a href="#基于注解的表单校验（含自定义注解）" class="headerlink" title="基于注解的表单校验（含自定义注解）"></a>基于注解的表单校验（含自定义注解）</h3><p>还有一种常见的业务场景就是后端接口需要对用户提交的表单进行校验。以“注册用户”这样的场景举例说明， 注册用户时，往往会提交昵称，性别，邮箱等信息进行注册，简单起见，就以这 3 个属性为例。</p><p>定义的表单如下：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegForm</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于表单的约束，我们有：</p><ul><li>昵称字段：“nickname” 必填，长度必须是 6 到 20 位；</li><li>性别字段：“gender” 可选，如果填了，就必须是“Male/Female/Other/”中的一种。说啥，除了男女还有其他？对，是的。毕竟全球用户嘛，你去看看非死不可，还有更多。</li><li>邮箱： “email”，必填，必须满足邮箱格式。</li></ul><p>对于以上约束，我们只需要在对应的字段上添加如下注解即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegForm</span> </span>&#123;</span><br><span class="line"><span class="meta">@Length</span>(min = <span class="number">6</span>, max = <span class="number">20</span>, message = <span class="string">"validate.userRegForm.nickname"</span>)</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Gender</span>(message=<span class="string">"validate.userRegForm.gender"</span>)</span><br><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Email</span>(message=<span class="string">"validate.userRegForm.email"</span>)</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在各个语言资源文件中配置好相应的错误信息提示即可。其中， <code>@Gender</code> 就是一个自定义的注解。</p><h3 id="基于含自定义注解的表单校验关键代码"><a href="#基于含自定义注解的表单校验关键代码" class="headerlink" title="基于含自定义注解的表单校验关键代码"></a>基于含自定义注解的表单校验关键代码</h3><p>自定义注解的实现主要的其实就是一个自定义注解的定义以及一个校验逻辑。<br>例如定义一个自定义注解 <code>CustomParam</code>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = CustomValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "name.tanglei.www.validator.CustomArray.defaultMessage"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CustomParam[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验逻辑的实现 <code>CustomValidator</code>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">CustomParam</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"tanglei"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error(constraintValidatorContext, <span class="string">"Invalid params: "</span> + s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CustomParam constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(ConstraintValidatorContext context, String message)</span> </span>&#123;</span><br><span class="line">        context.disableDefaultConstraintViolation();</span><br><span class="line">        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子只为了阐述说明问题，其中校验逻辑没有实际意义，这样，如果输入参数不满足条件，就会明确提示用户输入的哪个参数不满足条件。例如输入参数 <code>xx</code>，则会直接提示：<code>Invalid params: xx</code>。</p><p><img src="https://www.tanglei.name/resources/custom-validator-and-i18n-error-message-in-springboot/validator-bug.png" alt></p><p>这个跟第一部分的处理方式类似，因为现有的 validator 组件实现中，如果违反相应的约束也是一种抛异常的方式实现的，因此只需要在上述的 <code>GlobalExceptionHandler</code>中添加相应的异常信息即可，这里就不详述了。  这不是本文的重点，这里就不详细阐述了。 详细代码实现可以参考本人之前写的这篇文章<a href="/blog/custom-validator-and-i18n-error-message-in-springboot.html">一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</a>，上面有附完整的代码实现。</p><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><p>一切都显得很完美，直到上线前代码提交至安全团队扫描，就被“啪啪打脸”，扫描报告反馈了一个严重的安全漏洞。而这个安全漏洞，属于很高危的远程代码执行漏洞。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-1.gif" alt></p><p>用前文提到的自定义 Validator，输入的参数用： “1+1=${1+1}”，看看效果： </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-calc-4wx.png" alt></p><p>太 TM 神奇了，居然帮我运算出来了，返回 <code>&quot;message&quot;: &quot;Invalid params: 1+1=2&quot;</code>。 </p><p>问题就出现在实现自定义注解进行校验的这行代码（如下图所示）：</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-line-4wx.png" alt></p><p>其实，最开始的时候，这里直接返回了“Invalid params”，当初为了更好的用户体验，要明确告诉用户哪个参数没有通过校验，因此在输出的提示上加上了用户输入的字段，也就是上面的<code>&quot;Invalid params: &quot; + s</code>，没想到，这闯了大祸了（回过头来想，感觉这里没必要这么详细啊，因为前端已经有相应的校验了，正常情况下回拦住，针对不守规矩的用非常规手段来的接口请求，直接返回校验不通过就行了，毕竟不是对外提供的 OpenAPI 服务）。</p><p>仔细看，这个方法实际上是 <code>ConstraintValidatorContext</code>这个接口中声明的，看方法名字其实能知道输入参数是一个字符串模板，内部会进行解析替换的（这其实也符合“见名知意”的良好编程习惯）。（教训：<strong>大家应该把握好自己写的每一行代码背后实际在做什么</strong>。）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ......</span></span><br><span class="line"><span class="comment"> * @param messageTemplate new un-interpolated constraint message</span></span><br><span class="line"><span class="comment"> * @return returns a constraint violation builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ConstraintViolationBuilder <span class="title">buildConstraintViolationWithTemplate</span><span class="params">(String messageTemplate)</span></span>;</span><br></pre></td></tr></table></figure><p>这个 case，源码调试进去之后，就能跟踪到执行翻译阶段，在如下方法中： <code>org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.interpolateMessage</code>。  </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-interpolate-4wx.png" alt></p><p>再往后，就是表达式求值了。<br><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-plus11-4wx.png" alt></p><h3 id="以为就这样就完了吗？"><a href="#以为就这样就完了吗？" class="headerlink" title="以为就这样就完了吗？"></a>以为就这样就完了吗？</h3><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-2.jpeg" alt></p><p>刚开始感觉，能帮忙算简单的运算规则也就完了吧，你还能把我怎么样？其实这个相当于暴露了一个入口，支持用户输入任意 EL 表达式进行执行。网上通过关键字 “SpEL表达式注入漏洞” 找找，就能发现事情并没有想象中那么简单。</p><p>我们构造恰当的 EL 表达式（注意各种转义，下文的输入参数相对比较明显在做什么了，实际上还有更多黑科技，比如各种二进制转义编码啊等等），就能直接执行输入代码，例如：可以直接执行命令，“ls -al”， 返回了一个 UNIXProcess 实例，命令已经被执行过了。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-run-process-4wx.png" alt></p><p>比如，我们执行个打开计算器的命令，搞个计算器玩玩~ </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-run-open-calc-4wx.png" alt></p><p>我录制了一个动图，来个演示可能更生动一些。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/spel-bug-demo-0.gif" alt></p><p>这还得了吗？这相当于提供了一个 webshell 的功能呀，你看想运行啥命令就能运行啥命令，例如 ping 本人博客地址（<code>ping www.tanglei.name</code>），下面动图演示一下整个过程（从运行 ping 到 kill ping）。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/spel-demo-ping.gif" alt></p><p>我录制了一个视频，点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=100001493&amp;idx=1&amp;sn=d8d2374d8afa76e55bd37650c7ccde45&amp;chksm=6b4707315c308e273f4eb62799c65677d849104125bb6e7a56fbded981554fb92e97c289804e#rd" target="_blank" rel="noopener">这里</a>可以访问。</p><p>岂不是直接创建一个用户，然后远程登录就可以了。后果很严重啊，别人想干嘛就干嘛了。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-3.gif" alt></p><p>我们跟踪下对应的代码，看看内部实现，就会“恍然大悟”了。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-el-express-4wx.png" alt></p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-el-express-run-4wx.png" alt></p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>幸亏这个漏洞被扼杀在摇篮里，否则后果还真的挺严重的。通过这个案例，我们有啥经验和教训呢？那就是作为程序员，<strong>我们要对每一行代码都保持“敬畏”之心</strong>。也许就是因为你的不经意的一行代码就带来了严重的安全漏洞，要是不小心被坏人利用，轻则……重则……（自己想象吧） </p><p>此外，我们也应该看到，程序员需要对常见的安全漏洞（例如XSS/CSRF/SQL注入等等）有所了解，并且要有足够的安全意识（其实有时候研究一些安全问题还挺好玩的，比如这篇<a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483759&amp;idx=1&amp;sn=9b37547a51ac99a8d3d50cb9cf54a99a&amp;chksm=eb47008bdc30899dace5743edfc071d97d37764ed69bd9cebbfe32c14727a7407a6b8b76a433&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《RSA算法及一种”旁门左道”的攻击方式》</a>就比较有趣）。例如：</p><ul><li>用户权限分离：运行程序的用户不应该用 root，例如新建一个“web”或者“www”之类的用户，并设置该用户的权限，比如不能有可执行 xx 的权限之类的。本文 case，如果权限进行了分离（遵循最小权限原则），应该也不会这么严重。（本文就刚好是因为是测试环境，所以没有强制实施）</li><li>任何时候都不要相信用户的输入，必须对用户输入的进行校验和过滤，又特别是针对公网上的应用。</li><li>敏感信息加密保存。退一万步讲，假设攻击者攻入了你的服务器，如果这个时候，你的数据库账户信息等配置都直接明文保存在服务器中。那数据库也被脱走了。</li></ul><p>如果可能的话，需要对开发者的代码进行漏洞扫描。一些常见的安全漏洞现在应该是有现成的工具支持的。另外，让专业的人做专业的事情，例如要有安全团队，可能你会说你们公司没有不也活的好好的，哈哈，只不过可能还没有被坏人盯上而已，坏人也会考虑到他们的成本和预期收益的，当然这就更加对我们开发者提高了要求。一些敏感权限尽量控制在少部分人手中，配合相应的流程来支撑（不得不说，大公司繁琐的流程还是有一定道理的）。</p><p>毕竟我不是专业研究Web安全的，以上说得可能也不一定对，如果你有不同意见或者更好的建议欢迎留言参与讨论。</p><p>这篇文章从写代码做实验，到录屏做视频动图等等耗时还蛮久的（好几个周末的时间呢），原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗，或者转发分享让更多的小伙伴看到。</p><h5 id="精彩推荐"><a href="#精彩推荐" class="headerlink" title="精彩推荐"></a>精彩推荐</h5><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483933&amp;idx=1&amp;sn=69b1be012cf37ccb5ce6f3a091f57f5b&amp;chksm=eb4703f9dc308aef5834a6abf72255edd1767e633330531f817d7b4774c65c33f5910cd9ea75&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">一个由跨平台产生的浮点数bug | 有你意想不到的结果。</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483759&amp;idx=1&amp;sn=9b37547a51ac99a8d3d50cb9cf54a99a&amp;chksm=eb47008bdc30899dace5743edfc071d97d37764ed69bd9cebbfe32c14727a7407a6b8b76a433&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">RSA算法及一种”旁门左道”的攻击方式。</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483891&amp;idx=1&amp;sn=264171adf872514d1fd54faf54970dd7&amp;chksm=eb470017dc3089019ffc13facfdfb38e9d5f2adaf7fcbf9c117723ce015fb660f0802d406c7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">震惊! 阿里的程序员也不过如此,竟被一个简单的 SQL 查询难住。</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483912&amp;idx=1&amp;sn=520bbca6a2056ab4df6b0e1d0ebaf6e0&amp;chksm=eb4703ecdc308afa83b288b1469f0927c1916189f219ee5e8c3c5194defc0b8f313ff7607730&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">面了7轮 Google，最终还是逃不脱被挂的命运。</a></li></ul><blockquote><p>文章首发于本人微信公众号（ID：<code>tangleithu</code>），请感兴趣的同学关注我的微信公众号，及时获取技术干货。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在某厂的某次项目开发中，项目组同学设计和实现了一个“引以为傲”，额，有点扩张，不过自认为还说得过去的 feature，结果临上线前被啪啪打脸，因为实现过程中因为&lt;strong&gt;一行代码&lt;/strong&gt;（没有标题党，真的是一行代码）带来的安全漏洞让我们丢失了整个服务器控
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Java" scheme="https://www.tanglei.name/tags/Java/"/>
    
      <category term="网络安全" scheme="https://www.tanglei.name/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</title>
    <link href="https://www.tanglei.name/blog/custom-validator-and-i18n-error-message-in-springboot.html"/>
    <id>https://www.tanglei.name/blog/custom-validator-and-i18n-error-message-in-springboot.html</id>
    <published>2020-05-16T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-title.png" alt></p><p>本文通过示例说明，在 Springboot 中如何自定义 Validator，以及如何实现国际化的错误信息返回。注意，本文代码千万别直接照抄，有可能会出大事情的。先留个悬念，读者朋友们能从中看出有什么问题吗？</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>直接从 <a href="https://spring.io/guides/gs/rest-service/#initial" target="_blank" rel="noopener">springboot</a> 官网中下载模板，直接通过示例中的 <code>GreetingController</code> 添加实现逻辑。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String template = <span class="string">"Hello, %s!"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;Greeting&gt; <span class="title">greeting</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"World"</span>)</span> String name) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">"tangleithu"</span>.equals(name)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">"user.notFound"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Response.ok(<span class="keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, name)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码直接源自<a href="https://github.com/spring-guides/gs-rest-service.git" target="_blank" rel="noopener">官方 spring-guides 的 demo</a>，我稍微改吧改吧。正常情况下，能返回正确的结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># curl "localhost:8080/greeting?name=tangleithu&amp;lang=en" </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"Hello, tangleithu!"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国际化需求"><a href="#国际化需求" class="headerlink" title="国际化需求"></a>国际化需求</h2><p>作为高大上的项目，我们肯定有海外用户，所以就需要国际化的配置。现在来模拟了下业务逻辑，假设输入的参数有一些校验功能，比如以上name参数，假设和“tangleithu”不相等，就直接返回错误。同时希望返回的错误信息需要实现国际化，即在不同的语言环境下返回的结果不一样。例如中文：“没找到用户呢。” 对应的英文：“User does not exist.”，而对应的德文是……，算了忽略，我也不会。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-demo.png" alt></p><p>用一个图来表达，即希望实现的效果是，不同国家和地区的用户（不同语言）在遇到同一个业务场景下同一个错误原因，有不同的翻译。例如在参数校验没通过，Http Status Code应该返回 400，并告知错误原因；在具体的 Service 实现时可能也会遇到其他的 case 需要返回某种具体错误信息。</p><p>注意：实际业务场景中后端可能仅仅只返回错误码，具体的展示由前端根据 key 进行翻译。不过在一些更加灵活的场景中（例如有的 app 实现方案），错误信息很有可能会由后端接口直接返回。本文只是用了一个简单的案例阐述整个流程。</p><h2 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h2><p>​我们借助 Spring 中的 AOP，用一个 <code>ControllerAdvice</code> 统一拦截这种 <code>BadRequestException</code>异常。其他 Exception 也一样，做到异常信息统一处理，也不容易出现安全风险（之前有遇到过某大型网站因为后台发生异常，直接将具体的 SQL 错误暴露出来了，其中还不乏有表结构等敏感信息）。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BadRequestException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BadRequestException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国际化配置"><a href="#国际化配置" class="headerlink" title="国际化配置"></a>国际化配置</h2><p>然后，我们在这种具体的异常信息时，用一个 key 来标记错误码，在资源文件中用不同的语言来定义应该返回的具体错误信息。例如本文示例中，添加了中英文两种。 相应的目录结构如下： </p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-tree.png" alt></p><p>此时，我们只需要在 <code>GlobalExceptionHandler</code> 中根据请求来源是中文还是英文返回对应的错误信息即可。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getI18nMessage</span><span class="params">(String key, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LanguaggeUtils.currentLocale(request));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// log</span></span><br><span class="line">       <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求来源获取语言信息就有多种方式啦，例如我们可以从请求头中获取 <code>Accept-Lanuage</code>，一般浏览器会根据用户的设置情况带上这个请求头的，如下图所示。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-header.png" alt></p><p>或者我们自己显示定义一些例如 lang 之类的参数。本文不做详细阐述，咱们就简单用 <code>lang</code> 这个参数来定义，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanguaggeUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Locale <span class="title">currentLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 RequestHeader 等等获取相应的语言信息</span></span><br><span class="line">        <span class="comment">// 简单起见，直接从 queryParams 中取, 只模拟中英文</span></span><br><span class="line">        String locale = request.getParameter(<span class="string">"lang"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"zh"</span>.equalsIgnoreCase(locale)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Locale.CHINA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Locale.ENGLISH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过简单几行代码就能实现高大上的“国际化”参数返回了。 试试效果如下： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#curl "localhost:8080/greeting?name=tanglei&amp;lang=en" </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"User does not exist."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#curl "localhost:8080/greeting?name=tanglei&amp;lang=zh" </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"没找到用户呢。"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean-Validator"><a href="#Bean-Validator" class="headerlink" title="Bean Validator"></a>Bean Validator</h2><p>其实针对类似 Form 等参数校验，我们有更简单的方法。那就是借助 SpringBoot 中自带的 Validation 框架，本文用到的这个版本对应的实现是<code>jakarta.validation-api</code>。其实 Bean Validation 都有相应的标准，可能有不同的具体实现而已。对标准感兴趣的可以戳这里<a href="https://www.jcp.org/en/egc/view?id=380" target="_blank" rel="noopener">JSR #380 Bean Validation 2.0</a>。</p><p>回到本文的 demo 中，假设在我们业务逻辑中需要传递一个 <code>UserForm</code>，接收 <code>age,name,param</code> 三个参数。并对其中输入进行进行校验，其中，<code>param</code> 没有具体的含义，只是为了说明问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserForm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">0</span>, message = <span class="string">"validate.userform.age"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">120</span>, message = <span class="string">"validate.userform.age"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"validate.userform.name.notEmpty"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CustomParam</span>(message = <span class="string">"validate.userform.param.custom"</span>)</span><br><span class="line">    <span class="keyword">private</span> String param;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;Greeting&gt; <span class="title">createUser</span><span class="params">(@Valid @RequestBody UserForm userForm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Response.ok(<span class="keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, userForm.getName())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，上面示例只用了很简单的 <code>@Min, @Max, @NotNull</code>等约束条件，通过名字就能看出来含义。更多约束规则可以直接看对应源码 <code>javax.validation.constraints.xxx</code>，比如有常见的 <code>Email</code> 等格式校验。 </p><p>默认情况下，违反相应的约束条件后，默认的输出比较啰嗦，例如用这个请求 <code>curl -H &quot;Content-Type: application/json&quot; -d &quot;{}&quot; &quot;localhost:8080/user&quot;</code>，对应的输出如下： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Bad Request"</span>,</span><br><span class="line">    <span class="attr">"errors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"arguments"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"arguments"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"code"</span>: <span class="string">"name"</span>,</span><br><span class="line">                    <span class="attr">"codes"</span>: [</span><br><span class="line">                        <span class="string">"userForm.name"</span>,</span><br><span class="line">                        <span class="string">"name"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"defaultMessage"</span>: <span class="string">"name"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"bindingFailure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"NotBlank"</span>,</span><br><span class="line">            <span class="attr">"codes"</span>: [</span><br><span class="line">                <span class="string">"NotBlank.userForm.name"</span>,</span><br><span class="line">                <span class="string">"NotBlank.name"</span>,</span><br><span class="line">                <span class="string">"NotBlank.java.lang.String"</span>,</span><br><span class="line">                <span class="string">"NotBlank"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defaultMessage"</span>: <span class="string">"must not be blank"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"name"</span>,</span><br><span class="line">            <span class="attr">"objectName"</span>: <span class="string">"userForm"</span>,</span><br><span class="line">            <span class="attr">"rejectedValue"</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Validation failed for object='userForm'. Error count: 1"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/user"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2020-05-10T08:44:12.952+0000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实依葫芦画瓢，debug 的时候，把抛出的具体异常添加到前面的 <code>GlobalExceptionHandler</code>，再修改下默认的行为即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BindException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(ConstraintViolationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ConstraintViolationException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getConstraintViolations().iterator().next().getMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，增加自定义的 handler 后，返回信息结构一致方便前端统一处理，同时也简洁不少：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"validate.userform.name.notEmpty"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再结合前面讲解的通过i18n的参数配置，又可以实现当没通过校验的时候，错误信息统一由对应的国际化资源文件进行配置了。 </p><h2 id="自定义-Validator"><a href="#自定义-Validator" class="headerlink" title="自定义 Validator"></a>自定义 Validator</h2><p>当内置的满足不了条件的时候，我们希望实现自定义的 Validator，例如前文中的 <code>CustomParam</code>。</p><p>我们需要一个 Annotation，方便在对应 Form 的时候引用校验，具体实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = CustomValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "name.tanglei.www.validator.CustomArray.defaultMessage"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CustomParam[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要一个具体的 validator 实现类，通过上面的 <code>@Constraint(validatedBy = CustomValidator.class)</code> 关联起来。本文只是 demo，所以具体参数校验没有实际逻辑意义的，下面假设输入的参数和“tanglei”相同则校验通过，否则提示用户输入错误。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">CustomParam</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"tanglei"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error(constraintValidatorContext, <span class="string">"Invalid params: "</span> + s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CustomParam constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(ConstraintValidatorContext context, String message)</span> </span>&#123;</span><br><span class="line">        context.disableDefaultConstraintViolation();</span><br><span class="line">        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果，输入没校验通过，还提示你输入的参数 “xx” 不符合条件。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/validator-bug.png" alt></p><p>是不是感觉很完美？</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p></blockquote></blockquote></blockquote><p>重要的事情说三遍，总体来说本文思路还是值得借鉴的（对应代码见 <a href="https://github.com/tl3shi/demo.git" target="_blank" rel="noopener">github</a>），但一定要注意不要完全照抄，上面说的这个安全漏洞还挺严重的。给予点提示，就是在<code>CustomValidator</code> 的具体实现中，有朋友了解吗？欢迎留言讨论。我将在后面的文章中来讲述这个安全漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-title.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;本文通过示例说明，在 Springboot 中如何自定义 Valid
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Java" scheme="https://www.tanglei.name/tags/Java/"/>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>大家都知道递归，尾递归呢？什么又是尾递归优化？</title>
    <link href="https://www.tanglei.name/blog/tail-recursive-optimization.html"/>
    <id>https://www.tanglei.name/blog/tail-recursive-optimization.html</id>
    <published>2020-05-03T00:00:00.000Z</published>
    <updated>2020-10-23T15:12:13.961Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们来聊聊递归函数。为啥突然想到递归？其实就从电影名字《恐怖游轮》《盗梦空间》想到了。</p><h2 id="递归是啥"><a href="#递归是啥" class="headerlink" title="递归是啥"></a>递归是啥</h2><p>递归函数大家肯定写过，学校上课的时候，估计最开始的例子就是斐波拉契数列了吧。例如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数简而言之就是在一个函数中，又“递归”调用自己。在写递归函数的时候，需要注意的地方就是递归函数的结束条件。用递归函数确实能简化很多算法的实现，比如常见的二叉树遍历等。但往往在写递归函数的时候，最容易出现的问题就是所谓的“栈溢出”。</p><p>为什么会有“栈溢出”呢？因为函数调用的过程，都要借助“栈”这种存储结构来保存运行时的一些状态，比如函数调用过程中的变量拷贝，函数调用的地址等等。而“栈”往往存储空间是有限的，当超过其存储空间后，就会抛出著名的异常/错误“StackOverflowError”。</p><p>我们以一个简单的加法为例，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">100</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">1000000</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>很简答，编译运行后，比较小的数字，能得到正确的答案，当数字扩大后，就会直接发生“segmentation fault”。 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(python2<span class="number">.7</span>) ➜  hexo.tanglei.name git:(master) ✗ ./a.out</span><br><span class="line"><span class="number">5050</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">78159</span> segmentation fault  ./a.out</span><br></pre></td></tr></table></figure><h2 id="尾递归又是啥？"><a href="#尾递归又是啥？" class="headerlink" title="尾递归又是啥？"></a>尾递归又是啥？</h2><p>我得知这个概念，最开始还是因为很多年前一次面试，面试官问我“你知道什么是尾递归吗？”，我以为是“伪”递归，难道是假的递归？？？当初我也是懵逼状态（当初面试官忍住没笑也是厉害了）。从“尾”字可看出来即若函数在尾巴的地方递归调用自己。上面的例子写成尾递归，就变成了如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tailsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">return</span> tailsum(n<span class="number">-1</span>, sum+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以试试结果，计算从 1 加到 1000000，仍然是 <code>segmentation fault</code>。为什么呢？ 因为这种写法，本质上还是有多层的函数嵌套调用，中间仍然有压栈、出栈等占用了存储空间（只不过能比前面的方法会省部分空间）。 </p><h2 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h2><p>当你给编译选项开了优化之后，见证奇迹的时刻到了，居然能算出正确结果。如图所示： </p><p><img src="/resources/tail-recursive-optimization/tailrec-cpp.jpg" alt></p><p>原因就是因为编译器帮助做了尾递归优化，可以打开汇编代码看看（这里就不展示 C++的了）。后面我用大家比较熟悉的 JVM based 语言 Scala 来阐述这个优化过程。(好像 Java 的编译器没做这方面的优化，至少我实验我本地 JDK8 是没有的，不清楚最新版本的有木有)（scala 本身提供了一个注解帮助编译器强制校验是否能够进行尾递归优化<code>@tailrec</code>）</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TailRecObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">tailSum</span></span>(n: <span class="type">Int</span>, sum: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> tailSum(n<span class="number">-1</span>, n+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      println(tailSum(<span class="number">100</span>, <span class="number">0</span>))</span><br><span class="line">      println(tailSum(<span class="number">1000000</span>, <span class="number">0</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下所示，默认情况下 <code>scalac</code> 做了尾递归优化，能够正确计算出结果，当通过 <code>-g:notailcalls</code> 编译参数去掉尾递归优化后，就发生了 <code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code>了。</p><p><img src="/resources/tail-recursive-optimization/tailrec-scala.jpg" alt></p><p>我们来看看生成的字节码有什么不同。 </p><p><img src="/resources/tail-recursive-optimization/tailrec-scala-opti.jpg" alt="包含尾递归优化的字节码"></p><p><img src="/resources/tail-recursive-optimization/tailrec-scala-no-opti.jpg" alt="不包含尾递归优化的字节码"></p><p>从上面可以看出，尾递归优化后，变成循环了（前面的 C++ 类似）。</p><p>好了，尾递归咱们就了解到这里。个人看法，我们知道有“尾递归”这个点就好了，有时候我们写递归就是为了方便，代码可读性好，如果确实是出于性能考虑，我们可以自己用迭代的方式去实现，不依赖于具体的编译器实现。当然对于像 scala 这样，有一些语法糖能够帮助校验和验证，也是一个不错的选择。但递归转迭代的能力，我们能具备岂不更好。<br>下次想聊什么话题吗？欢迎留言。老规矩，如果有帮助（对你身边的其他人有帮助也行呀，一点帮助也没有也不会看到这里了，哈哈，莫要白嫖），写篇文章真心不容易，希望亲多多帮忙“在看”，转发分享支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，我们来聊聊递归函数。为啥突然想到递归？其实就从电影名字《恐怖游轮》《盗梦空间》想到了。&lt;/p&gt;
&lt;h2 id=&quot;递归是啥&quot;&gt;&lt;a href=&quot;#递归是啥&quot; class=&quot;headerlink&quot; title=&quot;递归是啥&quot;&gt;&lt;/a&gt;递归是啥&lt;/h2&gt;&lt;p&gt;递归函数大家肯定
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="递归" scheme="https://www.tanglei.name/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
